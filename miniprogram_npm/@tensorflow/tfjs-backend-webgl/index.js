/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core"],t):t((e=e||self).tf=e.tf||{},e.tf)}(this,(function(e,t){"use strict";var n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)};function r(e,t,n,r){return new(n||(n=Promise))((function(o,i){function a(e){try{s(r.next(e))}catch(e){i(e)}}function u(e){try{s(r.throw(e))}catch(e){i(e)}}function s(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,u)}s((r=r.apply(e,t||[])).next())}))}function o(e,t){var n,r,o,i,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:u(0),throw:u(1),return:u(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function u(i){return function(u){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(o=2&i[0]?r.return:i[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,i[1])).done)return o;switch(r=0,o&&(i=[2&i[0],o.value]),i[0]){case 0:case 1:o=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,r=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!(o=a.trys,(o=o.length>0&&o[o.length-1])||6!==i[0]&&2!==i[0])){a=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){a.label=i[1];break}if(6===i[0]&&a.label<o[1]){a.label=o[1],o=i;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(i);break}o[2]&&a.ops.pop(),a.trys.pop();continue}i=t.call(e,a)}catch(e){i=[6,e],r=0}finally{n=o=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,u])}}}var i,a,u,s={},l={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function c(e,t){s[e]=t}function d(e){if(!(e in s)){var t=function(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");var t=function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);if(t.addEventListener("webglcontextlost",(function(t){t.preventDefault(),delete s[e]}),!1),1===e)return t.getContext("webgl",l)||t.getContext("experimental-webgl",l);return t.getContext("webgl2",l)}(e);if(null===t)return console.log("Could not get context for WebGL version",e),null;s[e]=t}var n=s[e];return n.isContextLost()?(delete s[e],d(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),s[e])}function p(e,t){return[t,e]}function h(e){var n=t.util.sizeFromShape(e),r=Math.ceil(n/4);return t.util.sizeToSquarishShape(r)}function f(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function v(e,n){var r,o,i,a,u,s,l,c,d,p=e;return 2===t.env().getNumber("WEBGL_VERSION")?(r=p.R32F,o=p.R16F,i=p.RGBA16F,a=p.RGBA32F,u=p.RED,s=4,l=1,c=p.HALF_FLOAT,d=p.FLOAT):(r=e.RGBA,o=e.RGBA,i=e.RGBA,a=p.RGBA,u=e.RGBA,s=4,l=4,c=null!=n?n.HALF_FLOAT_OES:null,d=e.FLOAT),{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:a,textureFormatFloat:u,downloadTextureFormat:e.RGBA,downloadUnpackNumChannels:s,defaultNumChannels:l,textureTypeHalfFloat:c,textureTypeFloat:d}}function x(e,n){var r=n();return t.env().getBool("DEBUG")&&function(e){var t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+m(e,t))}(e),r}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(i||(i={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(a||(a={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(u||(u={}));function g(e){return!!(t.env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function m(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+t}}function C(e,t){return G(e,(function(){return e.getExtension(t)}),'Extension "'+t+'" not supported on this browser.')}function R(e,t){var n=G(e,(function(){return e.createShader(e.VERTEX_SHADER)}),"Unable to create vertex WebGLShader.");if(x(e,(function(){return e.shaderSource(n,t)})),x(e,(function(){return e.compileShader(n)})),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function y(e,n){var r=G(e,(function(){return e.createShader(e.FRAGMENT_SHADER)}),"Unable to create fragment WebGLShader.");if(x(e,(function(){return e.shaderSource(r,n)})),x(e,(function(){return e.compileShader(r)})),!1===e.getShaderParameter(r,e.COMPILE_STATUS))throw function(e,n){var r=E.exec(n);if(null==r)return console.log("Couldn't parse line number in error: "+n),void console.log(e);for(var o=+r[1],i=e.split("\n"),a=i.length.toString().length+2,u=i.map((function(e,n){return t.util.rightPad((n+1).toString(),a)+e})),s=0,l=0;l<u.length;l++)s=Math.max(u[l].length,s);var c=u.slice(0,o-1),d=u.slice(o-1,o),p=u.slice(o);console.log(c.join("\n")),console.log(n.split("\n")[0]),console.log("%c "+t.util.rightPad(d[0],s),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join("\n"))}(n,e.getShaderInfoLog(r)),new Error("Failed to compile fragment shader.");return r}var b,w,E=/ERROR: [0-9]+:([0-9]+):/g;function A(e){return G(e,(function(){return e.createProgram()}),"Unable to create WebGLProgram.")}function I(e,t){if(x(e,(function(){return e.linkProgram(t)})),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function T(e,t){if(x(e,(function(){return e.validateProgram(t)})),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function _(e,t){var n=G(e,(function(){return e.createBuffer()}),"Unable to create WebGLBuffer");return x(e,(function(){return e.bindBuffer(e.ARRAY_BUFFER,n)})),x(e,(function(){return e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)})),n}function O(e,t){var n=G(e,(function(){return e.createBuffer()}),"Unable to create WebGLBuffer");return x(e,(function(){return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)})),x(e,(function(){return e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)})),n}function S(e){return G(e,(function(){return e.createTexture()}),"Unable to create WebGLTexture.")}function N(e,n){var r=t.env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||n<=0){var o="["+e+"x"+n+"]";throw new Error("Requested texture size "+o+" is invalid.")}if(e>r||n>r){o="["+e+"x"+n+"]";throw new Error("Requested texture size "+o+" greater than WebGL maximum on this browser / GPU "+("["+r+"x"+r+"]")+".")}}function F(e){return G(e,(function(){return e.createFramebuffer()}),"Unable to create WebGLFramebuffer.")}function D(e,t,n,r,o,i,a){var u=e.getAttribLocation(t,n);return-1!==u&&(x(e,(function(){return e.bindBuffer(e.ARRAY_BUFFER,r)})),x(e,(function(){return e.vertexAttribPointer(u,o,e.FLOAT,!1,i,a)})),x(e,(function(){return e.enableVertexAttribArray(u)})),!0)}function k(e,t,n){z(e,n),x(e,(function(){return e.activeTexture(e.TEXTURE0+n)})),x(e,(function(){return e.bindTexture(e.TEXTURE_2D,t)}))}function B(e,t,n){return G(e,(function(){return e.getUniformLocation(t,n)}),'uniform "'+n+'" not present in program.')}function P(e,t,n){return e.getUniformLocation(t,n)}function L(e,t,n,r){x(e,(function(){return k(e,t,r)})),x(e,(function(){return e.uniform1i(n,r)}))}function V(e,t,n){x(e,(function(){return e.bindFramebuffer(e.FRAMEBUFFER,n)})),x(e,(function(){return e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)}))}function M(e,t){x(e,(function(){return e.bindFramebuffer(e.FRAMEBUFFER,t)})),x(e,(function(){return e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)}))}function W(e){var t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+U(e,t))}function U(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+t}}function G(e,t,n){var r=x(e,(function(){return t()}));if(null==r)throw new Error(n);return r}function z(e,t){var n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error("textureUnit must be in "+("[gl.TEXTURE0, gl.TEXTURE"+n+"]")+".")}function X(e,n){return void 0===n&&(n=2),t.util.sizeFromShape(e.slice(0,e.length-n))}function H(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function j(e){var t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[X(e)].concat(H(e))),t}function K(e,n){var r;void 0===n&&(n=!1);var o=t.env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n&&(o*=2,1===(e=e.map((function(n,r){return r>=e.length-2?t.util.nearestLargerEven(e[r]):e[r]}))).length&&(e=[2,e[0]])),2!==e.length){var i=t.util.squeezeShape(e);e=i.newShape}var a=t.util.sizeFromShape(e);if(e.length<=1&&a<=o)return[1,a];if(2===e.length&&e[0]<=o&&e[1]<=o)return e;if(3===e.length&&e[0]*e[1]<=o&&e[2]<=o)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=o&&e[1]*e[2]<=o)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=o&&e[3]<=o)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=o&&e[1]*e[2]*e[3]<=o)return[e[0],e[1]*e[2]*e[3]];if(n){var u=X(e),s=2,l=2;return e.length&&(s=(r=H(e))[0],l=r[1]),a=u*(s/2)*(l/2),t.util.sizeToSquarishShape(a).map((function(e){return 2*e}))}return t.util.sizeToSquarishShape(a)}function Y(e){return e%2==0}function q(e,n){if(e=e.slice(-2),n=n.slice(-2),t.util.arraysEqual(e,n))return!0;if(!e.length||!n.length)return!0;if(0===e[0]||0===e[1]||0===n[0]||0===n[1])return!0;if(e.length!==n.length){var r=e.slice(-1)[0],o=n.slice(-1)[0];if(r===o)return!0;if(Y(r)&&Y(o)&&(1===e[0]||1===n[0]))return!0}return e[1]===n[1]&&Y(e[0])&&Y(n[0])}function Q(e){if(null==b){var t=d(e);b=t.getParameter(t.MAX_TEXTURE_SIZE)}return b}function Z(e){if(null==w){var t=d(e);w=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,w)}function J(e){if(0===e)return 0;var t=d(e);return $(t,"EXT_disjoint_timer_query_webgl2")&&2===e?2:$(t,"EXT_disjoint_timer_query")?1:0}function $(e,t){return null!=e.getExtension(t)}function ee(e){try{if(null!=d(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function te(e){if(0===e)return!1;var t=d(e);if(1===e){if(!$(t,"OES_texture_float"))return!1}else if(!$(t,"EXT_color_buffer_float"))return!1;return re(t)}function ne(e){if(0===e)return!1;var t=d(e);if(1!==e){if($(t,"EXT_color_buffer_float"))return re(t);if($(t,"EXT_color_buffer_half_float")){var n=t.getExtension("EXT_color_buffer_half_float");return function(e,t){var n=v(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);var o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);var i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(o),i}(t,n)}return!1}return!!$(t,"OES_texture_float")&&(!!$(t,"WEBGL_color_buffer_float")&&re(t))}function re(e){var t=v(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);var r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);var o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),o}function oe(e){return 2===e&&null!=d(e).fenceSync}function ie(e,n){Array.isArray(e)||(e=[e]),e.forEach((function(e){null!=e&&t.util.assert("complex64"!==e.dtype,(function(){return n+" does not support complex64 tensors in the WebGL backend."}))}))}var ae={__proto__:null,callAndCheck:x,canBeRepresented:g,getWebGLErrorMessage:m,getExtensionOrThrow:C,createVertexShader:R,createFragmentShader:y,createProgram:A,linkProgram:I,validateProgram:T,createStaticVertexBuffer:_,createStaticIndexBuffer:O,getNumChannels:function(){return 2===t.env().getNumber("WEBGL_VERSION")?1:4},createTexture:S,validateTextureSize:N,createFramebuffer:F,bindVertexBufferToProgramAttribute:D,bindTextureUnit:k,unbindTextureUnit:function(e,t){z(e,t),x(e,(function(){return e.activeTexture(e.TEXTURE0+t)})),x(e,(function(){return e.bindTexture(e.TEXTURE_2D,null)}))},getProgramUniformLocationOrThrow:B,getProgramUniformLocation:P,bindTextureToProgramUniformSampler:L,bindCanvasToFramebuffer:function(e){x(e,(function(){return e.bindFramebuffer(e.FRAMEBUFFER,null)})),x(e,(function(){return e.viewport(0,0,e.canvas.width,e.canvas.height)})),x(e,(function(){return e.scissor(0,0,e.canvas.width,e.canvas.height)}))},bindColorTextureToFramebuffer:V,unbindColorTextureFromFramebuffer:M,validateFramebuffer:W,getFramebufferErrorMessage:U,getBatchDim:X,getRowsCols:H,getShapeAs3D:j,getTextureShapeFromLogicalShape:K,isReshapeFree:q,getWebGLMaxTextureSize:Q,resetMaxTextureSize:function(){b=null},resetMaxTexturesInShader:function(){w=null},getMaxTexturesInShader:Z,getWebGLDisjointQueryTimerVersion:J,hasExtension:$,isWebGLVersionEnabled:ee,isCapableOfRenderingToFloatTexture:te,isDownloadFloatTextureEnabled:ne,isWebGLFenceEnabled:oe,assertNotComplex:ie},ue=t.env();function se(e){return(n,r,o,i,a)=>{const u=t.backend_util.assertAndGetBroadcastShape(n,r),s=u.length,l=t.util.computeStrides(u),c=t.util.sizeFromShape(u),d=t.util.getTypedArrayFromDType(a,c),p=n.length,h=r.length,f=t.util.computeStrides(n),v=t.util.computeStrides(r),x=t.backend_util.getBroadcastDims(n,u),g=t.backend_util.getBroadcastDims(r,u);if(x.length+g.length===0)for(let t=0;t<d.length;++t)d[t]=e(o[t%o.length],i[t%i.length]);else for(let n=0;n<d.length;++n){const r=t.util.indexToLoc(n,s,l),a=r.slice(-p);x.forEach(e=>a[e]=0);const u=t.util.locToIndex(a,p,f),c=r.slice(-h);g.forEach(e=>c[e]=0);const m=t.util.locToIndex(c,h,v);d[n]=e(o[u],i[m])}return[d,u]}}ue.registerFlag("HAS_WEBGL",(function(){return ue.getNumber("WEBGL_VERSION")>0})),ue.registerFlag("WEBGL_VERSION",(function(){return ee(2)?2:ee(1)?1:0})),ue.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(function(){return!1})),ue.registerFlag("WEBGL_BUFFER_SUPPORTED",(function(){return 2===ue.get("WEBGL_VERSION")})),ue.registerFlag("WEBGL_CPU_FORWARD",(function(){return!0})),ue.registerFlag("WEBGL_FORCE_F16_TEXTURES",(function(){return!1})),ue.registerFlag("WEBGL_PACK",(function(){return ue.getBool("HAS_WEBGL")})),ue.registerFlag("WEBGL_PACK_NORMALIZATION",(function(){return ue.getBool("WEBGL_PACK")})),ue.registerFlag("WEBGL_PACK_CLIP",(function(){return ue.getBool("WEBGL_PACK")})),ue.registerFlag("WEBGL_PACK_DEPTHWISECONV",(function(){return!1})),ue.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(function(){return ue.getBool("WEBGL_PACK")})),ue.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(function(){return ue.getBool("WEBGL_PACK")})),ue.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(function(){return ue.getBool("WEBGL_PACK")})),ue.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(function(){return ue.getBool("WEBGL_PACK")})),ue.registerFlag("WEBGL_PACK_REDUCE",(function(){return ue.getBool("WEBGL_PACK")})),ue.registerFlag("WEBGL_LAZILY_UNPACK",(function(){return ue.getBool("WEBGL_PACK")})),ue.registerFlag("WEBGL_CONV_IM2COL",(function(){return ue.getBool("WEBGL_PACK")})),ue.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(function(){return Q(ue.getNumber("WEBGL_VERSION"))})),ue.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(function(){return Z(ue.getNumber("WEBGL_VERSION"))})),ue.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(function(){var e=ue.getNumber("WEBGL_VERSION");return 0===e?0:J(e)})),ue.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(function(){return ue.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!t.device_util.isMobile()})),ue.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(function(){return te(ue.getNumber("WEBGL_VERSION"))})),ue.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(function(){return!ue.getBool("WEBGL_FORCE_F16_TEXTURES")&&ue.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")})),ue.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(function(){return ne(ue.getNumber("WEBGL_VERSION"))})),ue.registerFlag("WEBGL_FENCE_API_ENABLED",(function(){return oe(ue.getNumber("WEBGL_VERSION"))})),ue.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(function(){return ue.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0})),ue.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(function(){return-1}),(function(e){if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got "+e+".")}));const le=se((e,t)=>e+t);function ce(e){return(n,r,o)=>{const i=t.util.getTypedArrayFromDType(r,n.length);for(let t=0;t<n.length;++t)i[t]=e(n[t],o);return i}}const de=ce(e=>Math.ceil(e)),pe=ce(e=>Math.exp(e)),he=ce(e=>Math.expm1(e)),fe=ce(e=>Math.floor(e)),ve=ce(e=>Math.log(e));const xe=se((e,t)=>e*t),ge=ce(e=>1/Math.sqrt(e));const me=se((e,t)=>e-t);var Ce=function(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t},Re=le,ye=de,be=pe,we=he,Ee=fe,Ae=ve,Ie=function(e,n,r,o){const i=t.util.getTypedArrayFromDType(o,t.util.sizeFromShape(r));for(let t=0;t<i.length;++t){const r=t*n;let o=e[r];for(let t=0;t<n;++t){const n=e[r+t];n>o&&(o=n)}i[t]=o}return i},Te=xe,_e=ge,Oe=function(e,n,r,o,i){const a=t.slice_util.isSliceContinous(o,n,r),u=t.util.sizeFromShape(r),s=t.util.computeStrides(o);if(a){const r=t.slice_util.computeFlatOffset(n,s);return e.subarray(r,r+u)}const l=t.util.getTypedArrayFromDType(i,u);for(let i=0;i<u;++i){const a=r.length,u=t.util.computeStrides(r),c=t.util.indexToLoc(i,a,u).map((e,t)=>e+n[t]),d=t.util.locToIndex(c,o.length,s);l[i]=e[d]}return l},Se=me,Ne=function(e,n,r,o,i){const a=n.length,u=t.util.sizeFromShape(n),s=t.util.computeStrides(n),l=t.util.computeStrides(i),c=t.util.getTypedArrayFromDType(r,t.util.sizeFromShape(i));for(let n=0;n<u;++n){const r=t.util.indexToLoc(n,a,s),i=new Array(r.length);for(let e=0;e<i.length;e++)i[e]=r[o[e]];c[t.util.locToIndex(i,a,l)]=e[n]}return c},Fe=function(e,n,r,o){const i=t.util.parseAxisParam(n,r)[0],a=[1,r[0],1];for(let e=0;e<i;e++)a[0]*=r[e];a[1]=r[i];for(let e=i+1;e<r.length;e++)a[2]*=r[e];const u={},s=new Int32Array(r[i]),l=new t.TensorBuffer(a,o,e),c=[],d=1===a[0]&&1===a[2];for(let t=0;t<r[i];t++){let n;if(d)n=e[t].toString();else{const e=[];for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)e.push(l.get(n,t,r));n=e.join(",")}if(void 0!==u[n])s[t]=u[n];else{const e=Object.keys(u).length;u[n]=e,s[t]=e,c.push(t)}}const p=a.slice();p[1]=Object.keys(u).length;const h=new t.TensorBuffer(p,o);c.forEach((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)h.set(l.get(n,e,r),n,t,r)});const f=r.slice();return f[i]=p[1],{outputValues:h.values,outputShape:f,indices:s}},De=function(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((function(e,t){return"T"+t}));var n=[];this.variableNames.forEach((function(e){n.push("float v"+e+" = get"+e+"AtOutCoords();")}));var r=this.variableNames.map((function(e){return"v"+e})).join(" + ");this.userCode="\n      void main() {\n        "+n.join("\n        ")+"\n\n        float result = "+r+";\n        setOutput(result);\n      }\n    "},ke=function(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((function(e,t){return"T"+t}));var n=[];this.variableNames.forEach((function(e){n.push("vec4 v"+e+" = get"+e+"AtOutCoords();")}));var r=this.variableNames.map((function(e){return"v"+e})).join(" + ");this.userCode="\n      void main() {\n        "+n.join("\n        ")+"\n\n        vec4 result = "+r+";\n        setOutput(result);\n      }\n    "},Be=function(e,t,n){this.variableNames=["A"];var r=e.windowSize,o=e.batchSize,i=e.outSize;n||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];var a="max"===t?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+r+";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < "+r+"; i++) {\n          int inIdx = "+u+";\n          float candidate = getA(batch, inIdx);\n          if (candidate "+a+" bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "};function Pe(e,t){return["x","y","z","w","u","v"].slice(0,t).map((function(t){return e+"."+t}))}function Le(e,t){return 1===t?[e]:Pe(e,t)}function Ve(){var e,n,r,o,i,a,u,s,l,c;return 2===t.env().getNumber("WEBGL_VERSION")?(e="#version 300 es",n="in",r="out",o="in",i="texture",a="outputColor",u="out vec4 outputColor;",s="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",n="attribute",r="varying",o="varying",i="texture2D",a="gl_FragColor",u="",s="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:n,varyingVs:r,varyingFs:o,texture2D:i,output:a,defineOutput:u,defineSpecialNaN:s,defineSpecialInf:l,defineRound:c}}function Me(e,n,r){void 0===r&&(r="index");var o=t.util.computeStrides(n);return o.map((function(t,n){return"int "+e[n]+" = "+r+" / "+t+"; "+(n===o.length-1?"int "+e[n+1]+" = "+r+" - "+e[n]+" * "+t:"index -= "+e[n]+" * "+t)+";"})).join("")}function We(e){var n=t.util.computeStrides(e).map((function(e){return e.toString()}));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * "+n[0]+" + coords.y * "+n[1]+" + coords.z;\n  }\n"}var Ue="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",Ge=t.backend_util.getBroadcastDims;function ze(e,n,r,o){var i=[];e.forEach((function(e){var n=t.util.sizeFromShape(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?i.push("uniform float "+e.name+(n>1?"["+n+"]":"")+";"):(i.push("uniform sampler2D "+e.name+";"),i.push("uniform int offset"+e.name+";"))}));var a,u,s=i.join("\n"),l=e.map((function(e){return function(e,n,r){void 0===r&&(r=!1);var o="";o+=r?He(e):Xe(e);var i=e.shapeInfo.logicalShape,a=n.logicalShape;i.length<=a.length&&(o+=r?function(e,n){var r,o=e.name,i=o.charAt(0).toUpperCase()+o.slice(1),a="get"+i+"AtOutCoords",u=e.shapeInfo.logicalShape.length,s=n.logicalShape.length,l=Ge(e.shapeInfo.logicalShape,n.logicalShape),c=Je(s),d=s-u,p=["x","y","z","w","u","v"];r=0===u?"":s<2&&l.length>=1?"coords = 0;":l.map((function(e){return"coords."+p[e+d]+" = 0;"})).join("\n");var h="";h=s<2&&u>0?"coords":e.shapeInfo.logicalShape.map((function(e,t){return"coords."+p[t+d]})).join(", ");var f="return outputValue;",v=1===t.util.sizeFromShape(e.shapeInfo.logicalShape),x=1===t.util.sizeFromShape(n.logicalShape);if(1!==u||v||x){if(v&&!x)f=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){var g=u-2,m=u-1;l.indexOf(g)>-1&&l.indexOf(m)>-1?f="return vec4(outputValue.x);":l.indexOf(g)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(m)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 "+a+"() {\n      "+c+" coords = getOutputCoords();\n      "+r+"\n      vec4 outputValue = get"+i+"("+h+");\n      "+f+"\n    }\n  "}(e,n):function(e,n){var r=e.name,o=r.charAt(0).toUpperCase()+r.slice(1),i="get"+o+"AtOutCoords",a=n.texShape,u=e.shapeInfo.texShape,s=e.shapeInfo.logicalShape.length,l=n.logicalShape.length;if(!e.shapeInfo.isUniform&&s===l&&null==e.shapeInfo.flatOffset&&t.util.arraysEqual(u,a))return"\n      float "+i+"() {\n        return sampleTexture("+r+", resultUV);\n      }\n    ";var c,d=Je(l),p=Ge(e.shapeInfo.logicalShape,n.logicalShape),h=l-s,f=["x","y","z","w","u","v"];c=0===s?"":l<2&&p.length>=1?"coords = 0;":p.map((function(e){return"coords."+f[e+h]+" = 0;"})).join("\n");var v="";v=l<2&&s>0?"coords":e.shapeInfo.logicalShape.map((function(e,t){return"coords."+f[t+h]})).join(", ");return"\n    float "+i+"() {\n      "+d+" coords = getOutputCoords();\n      "+c+"\n      return get"+o+"("+v+");\n    }\n  "}(e,n));return o}(e,n,o)})).join("\n"),c=n.texShape,d=Ve(),p=function(e){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return "+e.texture2D+"(textureSampler, uv).r;\n    }\n  "}(d),h=function(e){return e.version+"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    "+e.varyingFs+" vec2 resultUV;\n    "+e.defineOutput+"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    "+e.defineSpecialNaN+"\n    "+e.defineSpecialInf+"\n    "+e.defineRound+"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    "+je+"\n    "+Ke+"\n    "+Ye+"\n  "}(d);return n.isPacked?(a=function(e,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t){var n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===n[0])return"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * "+n[1]+".0);\n      }\n    ";if(1===n[1])return"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * "+n[0]+".0);\n      }\n    ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      return 2 * (resTexRC.x * "+n[1]+" + resTexRC.y);\n    }\n  "}(0,n);case 2:return function(e,n){var r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(t.util.arraysEqual(e,n))return"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2("+r[0]+", "+r[1]+"));\n      }\n    ";var o=Math.ceil(e[1]/2);return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+r[0]+", "+r[1]+"));\n\n      int index = resTexRC.x * "+r[1]+" + resTexRC.y;\n      int r = 2 * (index / "+o+");\n      int c = imod(index, "+o+") * 2;\n\n      return ivec2(r, c);\n    }\n  "}(e,n);case 3:return r=e,o=n,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],a=Math.ceil(r[2]/2),u=a*Math.ceil(r[1]/2),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+i[0]+", "+i[1]+"));\n      int index = resTexRC.x * "+i[1]+" + resTexRC.y;\n\n      int b = index / "+u+";\n      index -= b * "+u+";\n\n      int r = 2 * (index / "+a+");\n      int c = imod(index, "+a+") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";default:return function(e,t){for(var n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),o=r*Math.ceil(e[e.length-2]/2),i=o,a="",u="b, r, c",s=2;s<e.length-1;s++)i*=e[e.length-s-1],a="\n      int b"+s+" = index / "+i+";\n      index -= b"+s+" * "+i+";\n    "+a,u="b"+s+", "+u;return"\n    ivec"+e.length+" getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n\n      "+a+"\n\n      int b = index / "+o+";\n      index -= b * "+o+";\n\n      int r = 2 * (index / "+r+");\n      int c = imod(index, "+r+") * 2;\n\n      return ivec"+e.length+"("+u+");\n    }\n  "}(e,n)}var r,o,i,a,u}(n.logicalShape,c),u=function(e){return"\n    void setOutput(vec4 val) {\n      "+e.output+" = val;\n    }\n  "}(d)):(a=function(e,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t){if(1===t[0])return"\n      int getOutputCoords() {\n        return int(resultUV.x * "+t[1]+".0);\n      }\n    ";if(1===t[1])return"\n      int getOutputCoords() {\n        return int(resultUV.y * "+t[0]+".0);\n      }\n    ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+t[0]+", "+t[1]+"));\n      return resTexRC.x * "+t[1]+" + resTexRC.y;\n    }\n  "}(0,n);case 2:return function(e,n){if(t.util.arraysEqual(e,n))return"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+n[0]+", "+n[1]+"));\n      }\n    ";if(1===e[1])return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+n[0]+", "+n[1]+"));\n        int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";if(1===e[0])return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+n[0]+", "+n[1]+"));\n        int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      int r = index / "+e[1]+";\n      int c = index - r * "+e[1]+";\n      return ivec2(r, c);\n    }\n  "}(e,n);case 3:return r=n,o=Me(["r","c","d"],e),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+r[0]+", "+r[1]+"));\n      int index = resTexRC.x * "+r[1]+" + resTexRC.y;\n      "+o+"\n      return ivec3(r, c, d);\n    }\n  ";case 4:return function(e,t){var n=Me(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+t[0]+", "+t[1]+"));\n      int index = resTexRC.x * "+t[1]+" + resTexRC.y;\n      "+n+"\n      return ivec4(r, c, d, d2);\n    }\n  "}(e,n);case 5:return function(e,t){var n=Me(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2("+t[0]+",\n                             "+t[1]+"));\n\n      int index = resTexRC.x * "+t[1]+" + resTexRC.y;\n\n      "+n+"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "}(e,n);case 6:return function(e,t){var n=Me(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+t[0]+", "+t[1]+"));\n      int index = resTexRC.x * "+t[1]+" + resTexRC.y;\n\n      "+n+"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "}(e,n);default:throw new Error(e.length+"-D output sampling is not yet supported")}var r,o}(n.logicalShape,c),u=function(e){return"\n    void setOutput(float val) {\n      "+e.output+" = vec4(val, 0, 0, 0);\n    }\n  "}(d)),o&&(h+=qe),[h,p,u,s,a,l,r].join("\n")}function Xe(e){var n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e){var t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return"float "+n+"() {return "+t+";}";var r=e.shapeInfo.texShape,o=r[0],i=r[1];if(1===o&&1===i)return"\n      float "+n+"() {\n        return sampleTexture("+t+", halfCR);\n      }\n    ";var a=e.shapeInfo.texShape,u=a[0],s=a[1],l=Qe(t);return"\n    float "+n+"() {\n      vec2 uv = uvFromFlat("+u+", "+s+", "+l+");\n      return sampleTexture("+t+", uv);\n    }\n  "}(e);case 1:return function(e){var t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return"\n      float "+n+"(int index) {\n        "+Ze(e)+"\n      }\n    ";var r=e.shapeInfo.texShape,o=r[0],i=r[1];if(1===i&&1===o)return"\n      float "+n+"(int index) {\n        return sampleTexture("+t+", halfCR);\n      }\n    ";var a=Qe(t);if(1===i)return"\n      float "+n+"(int index) {\n        vec2 uv = vec2(0.5, (float(index + "+a+") + 0.5) / "+o+".0);\n        return sampleTexture("+t+", uv);\n      }\n    ";if(1===o)return"\n      float "+n+"(int index) {\n        vec2 uv = vec2((float(index + "+a+") + 0.5) / "+i+".0, 0.5);\n        return sampleTexture("+t+", uv);\n      }\n    ";return"\n    float "+n+"(int index) {\n      vec2 uv = uvFromFlat("+o+", "+i+", index + "+a+");\n      return sampleTexture("+t+", uv);\n    }\n  "}(e);case 2:return function(e){var n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape;if(null!=i&&t.util.arraysEqual(n,i)){var a=i[0],u=i[1];return"\n    float "+o+"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2("+u+".0, "+a+".0);\n      return sampleTexture("+r+", uv);\n    }\n  "}var s=t.util.squeezeShape(n),l=s.newShape,c=s.keptDims,d=l;if(d.length<n.length){var p=$e(e,d);return"\n      "+Xe(p)+"\n      float "+o+"(int row, int col) {\n        return "+o+"("+et(["row","col"],c)+");\n      }\n    "}if(e.shapeInfo.isUniform)return"\n      float "+o+"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2("+n[1]+", 1)));\n        "+Ze(e)+"\n      }\n    ";var h=i[0],f=i[1],v=Qe(r);if(1===f)return"\n    float "+o+"(int row, int col) {\n      float index = dot(vec3(row, col, "+v+"), vec3("+n[1]+", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / "+h+".0);\n      return sampleTexture("+r+", uv);\n    }\n  ";if(1===h)return"\n    float "+o+"(int row, int col) {\n      float index = dot(vec3(row, col, "+v+"), vec3("+n[1]+", 1, 1));\n      vec2 uv = vec2((index + 0.5) / "+f+".0, 0.5);\n      return sampleTexture("+r+", uv);\n    }\n  ";return"\n  float "+o+"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * "+n[1]+" + col + "+v+";\n    vec2 uv = uvFromFlat("+h+", "+f+", index);\n    return sampleTexture("+r+", uv);\n  }\n"}(e);case 3:return function(e){var n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[1]*n[2],a=n[2],u=t.util.squeezeShape(n),s=u.newShape,l=u.keptDims,c=s;if(c.length<n.length){var d=$e(e,c);return"\n        "+Xe(d)+"\n        float "+o+"(int row, int col, int depth) {\n          return "+o+"("+et(["row","col","depth"],l)+");\n        }\n      "}if(e.shapeInfo.isUniform)return"\n      float "+o+"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3("+i+", "+a+", 1)));\n        "+Ze(e)+"\n      }\n    ";var p=e.shapeInfo.texShape,h=p[0],f=p[1],v=e.shapeInfo.flatOffset;if(f===i&&null==v)return"\n        float "+o+"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2("+a+", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2("+f+".0, "+h+".0);\n          return sampleTexture("+r+", uv);\n        }\n      ";if(f===a&&null==v)return"\n    float "+o+"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2("+n[1]+", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+f+".0, "+h+".0);\n      return sampleTexture("+r+", uv);\n    }\n  ";var x=Qe(r);return"\n      float "+o+"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * "+i+" + col * "+a+" + depth + "+x+";\n        vec2 uv = uvFromFlat("+h+", "+f+", index);\n        return sampleTexture("+r+", uv);\n      }\n  "}(e);case 4:return function(e){var n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[3],a=n[2]*i,u=n[1]*a,s=t.util.squeezeShape(n),l=s.newShape,c=s.keptDims;if(l.length<n.length){var d=$e(e,l);return"\n      "+Xe(d)+"\n      float "+o+"(int row, int col, int depth, int depth2) {\n        return "+o+"("+et(["row","col","depth","depth2"],c)+");\n      }\n    "}if(e.shapeInfo.isUniform)return"\n      float "+o+"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4("+u+", "+a+", "+i+", 1)));\n        "+Ze(e)+"\n      }\n    ";var p=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,f=h[0],v=h[1];if(v===u&&null==p)return"\n      float "+o+"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3("+a+", "+i+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+v+".0, "+f+".0);\n        return sampleTexture("+r+", uv);\n      }\n    ";if(v===i&&null==p)return"\n      float "+o+"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3("+n[1]*n[2]+", "+n[2]+", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+v+".0, "+f+".0);\n        return sampleTexture("+r+", uv);\n      }\n    ";var x=Qe(r);return"\n    float "+o+"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+u+" + col * "+a+" +\n          depth * "+i+" + depth2;\n      vec2 uv = uvFromFlat("+f+", "+v+", index + "+x+");\n      return sampleTexture("+r+", uv);\n    }\n  "}(e);case 5:return function(e){var n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[4],a=n[3]*i,u=n[2]*a,s=n[1]*u,l=t.util.squeezeShape(n),c=l.newShape,d=l.keptDims;if(c.length<n.length){var p=$e(e,c);return"\n      "+Xe(p)+"\n      float "+o+"(int row, int col, int depth, int depth2, int depth3) {\n        return "+o+"("+et(["row","col","depth","depth2","depth3"],d)+");\n      }\n    "}if(e.shapeInfo.isUniform)return"\n      float "+o+"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+s+", "+u+", "+a+", "+i+")) +\n          depth3;\n        "+Ze(e)+"\n      }\n    ";var h=e.shapeInfo.flatOffset,f=e.shapeInfo.texShape,v=f[0],x=f[1];if(x===s&&null==h)return"\n      float "+o+"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4("+u+", "+a+", "+i+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+x+".0, "+v+".0);\n        return sampleTexture("+r+", uv);\n      }\n    ";if(x===i&&null==h)return"\n      float "+o+"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+n[1]*n[2]*n[3]+",\n               "+n[2]*n[3]+", "+n[3]+", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+x+".0, "+v+".0);\n        return sampleTexture("+r+", uv);\n      }\n    ";var g=Qe(r);return"\n    float "+o+"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+s+" + col * "+u+" + depth * "+a+" +\n          depth2 * "+i+" + depth3 + "+g+";\n      vec2 uv = uvFromFlat("+v+", "+x+", index);\n      return sampleTexture("+r+", uv);\n    }\n  "}(e);case 6:return function(e){var n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t.util.squeezeShape(n),a=i.newShape,u=i.keptDims;if(a.length<n.length){var s=$e(e,a);return"\n      "+Xe(s)+"\n      float "+o+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return "+o+"("+et(["row","col","depth","depth2","depth3","depth4"],u)+");\n      }\n    "}var l=n[5],c=n[4]*l,d=n[3]*c,p=n[2]*d,h=n[1]*p;if(e.shapeInfo.isUniform)return"\n      float "+o+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4("+h+", "+p+", "+d+", "+c+")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2("+l+", 1)));\n        "+Ze(e)+"\n      }\n    ";var f=e.shapeInfo.flatOffset,v=e.shapeInfo.texShape,x=v[0],g=v[1];if(g===h&&null==f)return"\n      float "+o+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4("+p+", "+d+", "+c+", "+l+")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+g+".0, "+x+".0);\n        return sampleTexture("+r+", uv);\n      }\n    ";if(g===l&&null==f)return"\n      float "+o+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4("+n[1]*n[2]*n[3]*n[4]+",\n               "+n[2]*n[3]*n[4]+",\n               "+n[3]*n[4]+",\n               "+n[4]+")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+g+".0, "+x+".0);\n        return sampleTexture("+r+", uv);\n      }\n    ";var m=Qe(r);return"\n    float "+o+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+h+" + col * "+p+" + depth * "+d+" +\n          depth2 * "+c+" + depth3 * "+l+" + depth4 + "+m+";\n      vec2 uv = uvFromFlat("+x+", "+g+", index);\n      return sampleTexture("+r+", uv);\n    }\n  "}(e);default:throw new Error(n.length+"-D input sampling is not yet supported")}}function He(e){var n,r,o;switch(e.shapeInfo.logicalShape.length){case 0:return n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=Ve(),"\n    vec4 "+r+"() {\n      return "+o.texture2D+"("+n+", halfCR);\n    }\n  ";case 1:return function(e){var t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],i=Ve();return"\n    vec4 "+n+"(int index) {\n      vec2 uv = packedUVfrom1D(\n        "+o[0]+", "+o[1]+", index);\n      return "+i.texture2D+"("+t+", uv);\n    }\n  "}(e);case 2:return function(e){var n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape,a=i[0],u=i[1],s=Ve();if(null!=i&&t.util.arraysEqual(n,i))return"\n      vec4 "+o+"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2("+u+".0, "+a+".0);\n\n        return "+s.texture2D+"("+r+", uv);\n      }\n    ";var l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=Math.ceil(n[1]/2);return"\n    vec4 "+o+"(int row, int col) {\n      vec2 uv = packedUVfrom2D("+c+", "+l[0]+", "+l[1]+", row, col);\n      return "+s.texture2D+"("+r+", uv);\n    }\n  "}(e);case 3:return function(e){var t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===t[0]){var a=t.slice(1),u=$e(e,a);return"\n        "+He(u)+"\n        vec4 "+r+"(int b, int row, int col) {\n          return "+r+"("+et(["b","row","col"],[1,2])+");\n        }\n      "}var s=i[0],l=i[1],c=Math.ceil(t[2]/2),d=c*Math.ceil(t[1]/2),p=Ve();return"\n    vec4 "+r+"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        "+s+", "+l+", "+d+", "+c+", b, row, col);\n      return "+p.texture2D+"("+n+", uv);\n    }\n  "}(e);default:return function(e){for(var t=e.shapeInfo.logicalShape,n=t.length,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape,a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],u=a[0],s=a[1],l=Math.ceil(t[n-1]/2),c=l*Math.ceil(t[n-2]/2),d="int b, int row, int col",p="b * "+c+" + (row / 2) * "+l+" + (col / 2)",h=2;h<n-1;h++)d="int b"+h+", "+d,c*=t[n-h-1],p="b"+h+" * "+c+" + "+p;var f=Ve();return"\n    vec4 "+o+"("+d+") {\n      int index = "+p+";\n      int texR = index / "+s+";\n      int texC = index - texR * "+s+";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+s+", "+u+");\n      return "+f.texture2D+"("+r+", uv);\n    }\n  "}(e)}}var je="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ke="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ye="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",qe="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Qe(e){return"offset"+e}function Ze(e){var n=e.name,r=t.util.sizeFromShape(e.shapeInfo.logicalShape);return r<2?"return "+n+";":"\n    for (int i = 0; i < "+r+"; i++) {\n      if (i == index) {\n        return "+n+"[i];\n      }\n    }\n  "}function Je(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank "+e+" is not yet supported")}function $e(e,t){var n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function et(e,t){return t.map((function(t){return e[t]})).join(", ")}var tt=function(e,n,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,t.util.assert(e.length>2,(function(){return"Packed arg"+(r.charAt(0).toUpperCase()+r.slice(1))+" supports only inputs with rank above 2."}));var i=e[e.length-1],a=Math.ceil(i/n);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),o||this.variableNames.push("bestIndicesA");var u,s,l=this.outputShape,c=l.length,d=Je(c),p=Le("coords",c);if(1===a){var h=Je(s=c+1);u="\n        "+h+" sourceLocR = "+h+"("+p.join()+", 0);\n        ++"+p[c-1]+";\n        "+h+" sourceLocG = "+h+"("+p.join()+", 0);\n        ++"+p[c-2]+";\n        "+h+" sourceLocA = "+h+"("+p.join()+", 0);\n        --"+p[c-1]+";\n        "+h+" sourceLocB = "+h+"("+p.join()+", 0);\n        --"+p[c-2]+";"}else s=c,u="\n        "+d+" sourceLocR = coords;\n        ++"+p[c-1]+";\n        "+d+" sourceLocG = coords;\n        ++"+p[c-2]+";\n        "+d+" sourceLocA = coords;\n        --"+p[c-1]+";\n        "+d+" sourceLocB = coords;\n        --"+p[c-2]+";";var f=["x","y","z","w","u","v"].slice(0,s),v="."+f[s-1],x=f.map((function(e){return"int "+e})),g=Le("sourceLocR",s-1).concat("inIdx.r"),m=Le("sourceLocG",s-1).concat("inIdx.g"),C=Le("sourceLocB",s-1).concat("inIdx.b"),R=Le("sourceLocA",s-1).concat("inIdx.a"),y="max"===r?"greaterThan":"lessThan",b=o?"":"\n          inIdx = round(vec4(getBestIndicesAChannel("+g.join()+"),\n                             getBestIndicesAChannel("+m.join()+"),\n                             getBestIndicesAChannel("+C.join()+"),\n                             getBestIndicesAChannel("+R.join()+")));",w="vec4(\n            getAChannel("+g.join()+"),\n            hasNextCol ? getAChannel("+m.join()+") : 0.,\n            hasNextRow ? getAChannel("+C.join()+") : 0.,\n            hasNextRow && hasNextCol ? getAChannel("+R.join()+") : 0.)",E=o?"":"\n      float getBestIndicesAChannel("+x.join()+") {\n        return getChannel(getBestIndicesA("+f.join()+"),\n                                          vec2("+f.slice(-2).join()+"));\n      }";this.userCode="\n      float getAChannel("+x.join()+") {\n        return getChannel(getA("+f.join()+"),\n                               vec2("+f.slice(-2).join()+"));\n      }\n      "+E+"\n      void main() {\n        "+d+" coords = getOutputCoords();\n        bool hasNextCol = "+p[c-1]+" < "+(l[c-1]-1)+";\n        bool hasNextRow = "+p[c-2]+" < "+(l[c-2]-1)+";\n        "+u+"\n        ivec4 srcIdx = ivec4(sourceLocR"+v+", sourceLocG"+v+",\n          sourceLocB"+v+", sourceLocA"+v+") * "+n+";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = "+w+";\n\n        for (int i = 0; i < "+n+"; i++) {\n          inIdx = srcIdx;\n          "+b+"\n          vec4 candidate = "+w+";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4("+y+"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    "},nt=function(e){this.variableNames=["dy"],this.outputShape=e.inShape;var t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,o=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterHeight,s=e.effectiveFilterWidth,l=u-1-e.padInfo.top,c=s-1-e.padInfo.left,d=1/(t*n);this.userCode="\n      const ivec2 pads = ivec2("+l+", "+c+");\n      const float avgMultiplier = float("+d+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+u+";\n            wR += "+i+") {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+e.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+s+";\n            wC+= "+a+") {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},rt=function(e){this.variableNames=["dy"],this.outputShape=e.inShape;var t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,s=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=c-1-e.padInfo.front,f=d-1-e.padInfo.top,v=p-1-e.padInfo.left,x=1/(t*n*r);this.userCode="\n      const ivec3 pads = ivec3("+h+", "+f+", "+v+");\n      const float avgMultiplier = float("+x+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < "+c+";\n            wD += "+u+") {\n          float dyD = float(dyDCorner + wD) / "+o+".0;\n\n          if (dyD < 0.0 || dyD >= "+e.outDepth+".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < "+d+";\n              wR += "+s+") {\n            float dyR = float(dyRCorner + wR) / "+i+".0;\n\n            if (dyR < 0.0 || dyR >= "+e.outHeight+".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < "+p+";\n                wC += "+l+") {\n              float dyC = float(dyCCorner + wC) / "+a+".0;\n\n              if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},ot="return areal * breal - aimag * bimag;",it="return areal * bimag + aimag * breal;",at=function(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=t.backend_util.assertAndGetBroadcastShape(n,r),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        "+e+"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "},ut="return a + b;",st="return a - b;",lt="return a * b;",ct="return (a < 0.) ? b * a : a;",dt=function(e,n,r){this.variableNames=["A","B"],this.outputShape=t.backend_util.assertAndGetBroadcastShape(n,r),this.userCode="\n      float binaryOperation(float a, float b) {\n        "+e+"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "},pt="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",ht=function(e,n,r,o){void 0===o&&(o=!1),this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.backend_util.assertAndGetBroadcastShape(n,r);var i=this.outputShape.length,a="";if(o)if(0===i||1===t.util.sizeFromShape(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a="\n          "+Je(i)+" coords = getOutputCoords();\n        ",1===i)a+="\n            result.y = (coords + 1) >= "+this.outputShape[0]+" ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";else{var u=Le("coords",i);a+="\n            bool nextRowOutOfBounds =\n              ("+u[i-2]+" + 1) >= "+this.outputShape[i-2]+";\n            bool nextColOutOfBounds =\n              ("+u[i-1]+" + 1) >= "+this.outputShape[i-1]+";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        "+e+"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        "+a+"\n\n        setOutput(result);\n      }\n    "},ft=function(){function e(e){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}return e.prototype.getCustomSetupFunc=function(e,t){var n=this;return function(r,o){null==n.minLoc&&(n.minLoc=r.getUniformLocationNoThrow(o,"minVal"),n.maxLoc=r.getUniformLocationNoThrow(o,"maxVal")),r.gl.uniform1f(n.minLoc,e),r.gl.uniform1f(n.maxLoc,t)}},e}(),vt=function(){function e(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}return e.prototype.getCustomSetupFunc=function(e,t){var n=this;return function(r,o){null==n.minLoc&&(n.minLoc=r.getUniformLocationNoThrow(o,"minVal"),n.maxLoc=r.getUniformLocationNoThrow(o,"maxVal")),r.gl.uniform1f(n.minLoc,e),r.gl.uniform1f(n.maxLoc,t)}},e}(),xt=function(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "},gt=function(e){this.outputShape=[],this.outputShape=t.backend_util.computeOutShape(e,1),this.variableNames=e.map((function(e,t){return"T"+t}));var n=new Array(e.length-1);n[0]=e[0][1];for(var r=1;r<n.length;r++)n[r]=n[r-1]+e[r][1];var o=["if (yC < "+n[0]+") setOutput(getT0(yR, yC));"];for(r=1;r<n.length;r++){var i=n[r-1];o.push("else if (yC < "+n[r]+") setOutput(getT"+r+"(yR, yC-"+i+"));")}var a=n.length,u=n[n.length-1];o.push("else setOutput(getT"+a+"(yR, yC-"+u+"));"),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        "+o.join("\n        ")+"\n      }\n    "},mt=function(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=t.backend_util.computeOutShape(e,n);var r=this.outputShape,o=r.length,i=Je(o),a=Le("coords",o),u=["x","y","z","w","u","v"].slice(0,o);this.variableNames=e.map((function(e,t){return"T"+t}));var s=new Array(e.length-1);s[0]=e[0][n];for(var l=1;l<s.length;l++)s[l]=s[l-1]+e[l][n];var c=u[n],d=u.slice(-2),p=u.join(),h="if ("+c+" < "+s[0]+") {\n        return getChannel(\n            getT0("+p+"), vec2("+d.join()+"));\n        }";for(l=1;l<s.length;l++){var f=s[l-1];h+="\n        if ("+c+" < "+s[l]+"  && "+c+" >= "+s[l-1]+") {\n          return getChannel(\n            getT"+l+"("+Ct(u,c,f)+"),\n            vec2("+Ct(d,c,f)+"));\n        }"}var v=s.length,x=s[s.length-1];h+="\n        return getChannel(\n          getT"+v+"("+Ct(u,c,x)+"),\n          vec2("+Ct(d,c,x)+"));",this.userCode="\n      float getValue("+u.map((function(e){return"int "+e}))+") {\n        "+h+"\n      }\n\n      void main() {\n        "+i+" coords = getOutputCoords();\n        vec4 result = vec4(getValue("+a+"), 0., 0., 0.);\n\n        "+a[o-1]+" = "+a[o-1]+" + 1;\n        if ("+a[o-1]+" < "+r[o-1]+") {\n          result.g = getValue("+a+");\n        }\n\n        "+a[o-2]+" = "+a[o-2]+" + 1;\n        if ("+a[o-2]+" < "+r[o-2]+") {\n          result.a = getValue("+a+");\n        }\n\n        "+a[o-1]+" = "+a[o-1]+" - 1;\n        if ("+a[o-2]+" < "+r[o-2]+" &&\n            "+a[o-1]+" < "+r[o-1]+") {\n          result.b = getValue("+a+");\n        }\n        setOutput(result);\n      }\n    "};function Ct(e,t,n){var r=e.indexOf(t);return e.map((function(e,t){return t===r?e+" - "+n:e})).join()}var Rt=function(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;var t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,i="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+e.batchSize+"; b++) {\n          for (int yR = 0; yR < "+e.outHeight+"; yR++) {\n            int xR = wR + yR * "+t+" - "+r+";\n\n            if (xR < 0 || xR >= "+e.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+e.outWidth+"; yC++) {\n              int xC = wC + yC * "+n+" - "+o+";\n\n              if (xC < 0 || xC >= "+e.inWidth+") {\n                continue;\n              }\n\n              if ("+i+") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},yt=function(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;var t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,o=e.strideWidth,i="channelsLast"===e.dataFormat,a=t-1-e.padInfo.top,u=n-1-e.padInfo.left,s=i?1:2,l=i?2:3,c=i?3:1;this.userCode="\n      const ivec2 pads = ivec2("+a+", "+u+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords["+c+"];\n\n        ivec2 dyCorner = ivec2(coords["+s+"], coords["+l+"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+t+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+e.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+t+" - 1 - wR;\n\n          for (int wC = 0; wC < "+n+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+n+" - 1 - wC;\n\n            for (int d2 = 0; d2 < "+e.outChannels+"; d2++) {\n\n              if ("+i+") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},bt=function(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;var t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,o=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+e.batchSize+"; b++) {\n          for (int yF = 0; yF < "+e.outDepth+"; yF++) {\n            int xF = wF + yF * "+t+" - "+o+";\n\n            if (xF < 0 || xF >= "+e.inDepth+") {\n              continue;\n            }\n\n            for (int yR = 0; yR < "+e.outHeight+"; yR++) {\n              int xR = wR + yR * "+n+" - "+i+";\n\n              if (xR < 0 || xR >= "+e.inHeight+") {\n                continue;\n              }\n\n              for (int yC = 0; yC < "+e.outWidth+"; yC++) {\n                int xC = wC + yC * "+r+" - "+a+";\n\n                if (xC < 0 || xC >= "+e.inWidth+") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},wt=function(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;var t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=t-1-e.padInfo.front,s=n-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+u+", "+s+", "+l+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+t+"; wF++) {\n          float dyF = float(dyFCorner + wF) / "+o+".0;\n\n          if (dyF < 0.0 || dyF >= "+e.outDepth+".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = "+t+" - 1 - wF;\n\n          for (int wR = 0; wR < "+n+"; wR++) {\n            float dyR = float(dyRCorner + wR) / "+i+".0;\n\n            if (dyR < 0.0 || dyR >= "+e.outHeight+".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = "+n+" - 1 - wR;\n\n            for (int wC = 0; wC < "+r+"; wC++) {\n              float dyC = float(dyCCorner + wC) / "+a+".0;\n\n              if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = "+r+" - 1 - wC;\n\n              for (int d2 = 0; d2 < "+e.outChannels+"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Et=function(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;var t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * "+i+" + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < "+e.batchSize+"; b++) {\n          for (int yR = 0; yR < "+e.outHeight+"; yR++) {\n            int xR = wR + yR * "+t+" - "+r+";\n\n            if (xR < 0 || xR >= "+e.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+e.outWidth+"; yC++) {\n              int xC = wC + yC * "+n+" - "+o+";\n\n              if (xC < 0 || xC >= "+e.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},At=function(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;var t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,o=e.strideWidth,i=t-1-e.padInfo.top,a=n-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2("+i+", "+a+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < "+t+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+e.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+t+" - 1 - wR;\n\n          for (int wC = 0; wC < "+n+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+n+" - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < "+u+"; dm++) {\n              int d2 = d1 * "+u+" + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},It=function(e,t,n,r){void 0===t&&(t=!1),void 0===n&&(n=null),void 0===r&&(r=!1),this.variableNames=["x","W"],this.outputShape=e.outShape;var o=e.padInfo.top,i=e.padInfo.left,a=e.strideHeight,u=e.strideWidth,s=e.dilationHeight,l=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),h=e.inChannels%4,f="channelsLast"===e.dataFormat,v=f?1:2,x=f?2:3,g=f?3:1,m="",C="";n&&(m=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          "+n+"\n        }":"\n          float activation(float x) {\n            "+n+"\n          }\n        ",C="result = activation(result);");var R=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+m+"\n\n      const ivec2 strides = ivec2("+a+", "+u+");\n      const ivec2 pads = ivec2("+o+", "+i+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords["+g+"];\n\n        ivec2 xRCCorner =\n            ivec2(coords["+v+"], coords["+x+"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+c+"; wR++) {\n          int xR = xRCorner + wR * "+s+";\n\n          if (xR < 0 || xR >= "+e.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+d+"; wC++) {\n            int xC = xCCorner + wC * "+l+";\n\n            if (xC < 0 || xC >= "+e.inWidth+") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < "+p+"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if ("+f+") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if ("+(1===h)+") {\n\n              if ("+f+") {\n                dotProd +=\n                    getX(batch, xR, xC, "+p+") *\n                    getW(wR, wC, "+p+", d2);\n              } else {\n                dotProd +=\n                    getX(batch, "+p+", xR, xC) *\n                    getW(wR, wC, "+p+", d2);\n              }\n\n            } else if ("+(2===h)+") {\n              vec2 wValues = vec2(\n                getW(wR, wC, "+p+", d2),\n                getW(wR, wC, "+p+" + 1, d2)\n              );\n\n              if ("+f+") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, "+p+"),\n                  getX(batch, xR, xC, "+p+" + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, "+p+", xR, xC),\n                  getX(batch, "+p+" + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if ("+(3===h)+") {\n              vec3 wValues = vec3(\n                getW(wR, wC, "+p+", d2),\n                getW(wR, wC, "+p+" + 1, d2),\n                getW(wR, wC, "+p+" + 2, d2)\n              );\n\n              if ("+f+") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, "+p+"),\n                  getX(batch, xR, xC, "+p+" + 1),\n                  getX(batch, xR, xC, "+p+" + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, "+p+", xR, xC),\n                  getX(batch, "+p+" + 1, xR, xC),\n                  getX(batch, "+p+" + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        "+R+"\n        "+C+"\n        setOutput(result);\n      }\n    "},Tt=function(e){this.variableNames=["x","W"],this.outputShape=e.outShape;var t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,s=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3("+o+", "+i+", "+a+");\n      const ivec3 pads = ivec3("+t+", "+n+", "+r+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+c+"; wF++) {\n          int xF = xFCorner + wF * "+u+";\n\n          if (xF < 0 || xF >= "+e.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+d+"; wR++) {\n            int xR = xRCorner + wR * "+s+";\n\n            if (xR < 0 || xR >= "+e.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+p+"; wC++) {\n              int xC = xCCorner + wC * "+l+";\n\n              if (xC < 0 || xC >= "+e.inWidth+") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < "+h+"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if ("+(1===f)+") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, "+h+") *\n                  getW(wF, wR, wC, "+h+", d2);\n              } else if ("+(2===f)+") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, "+h+"),\n                  getX(batch, xF, xR, xC, "+h+" + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, "+h+", d2),\n                  getW(wF, wR, wC, "+h+" + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if ("+(3===f)+") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, "+h+"),\n                  getX(batch, xF, xR, xC, "+h+" + 1),\n                  getX(batch, xF, xR, xC, "+h+" + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, "+h+", d2),\n                  getW(wF, wR, wC, "+h+" + 1, d2),\n                  getW(wF, wR, wC, "+h+" + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},_t=function(e,t,n,r){void 0===t&&(t=!1),void 0===n&&(n=null),void 0===r&&(r=!1),this.variableNames=["x","W"],this.outputShape=e.outShape;var o=e.inHeight,i=e.inWidth,a=e.padInfo.top,u=e.padInfo.left,s=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,p=e.filterHeight,h=e.filterWidth,f=e.outChannels/e.inChannels,v="",x="";n&&(v=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          "+n+"\n        }":"\n          float activation(float x) {\n            "+n+"\n          }\n        ",x="result = activation(result);");var g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+v+"\n\n      const ivec2 strides = ivec2("+s+", "+l+");\n      const ivec2 pads = ivec2("+a+", "+u+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / "+f+";\n        int q = d2 - d1 * "+f+";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < "+p+"; wR++) {\n          int xR = xRCorner + wR * "+c+";\n\n          if (xR < 0 || xR >= "+o+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+h+"; wC++) {\n            int xC = xCCorner + wC * "+d+";\n\n            if (xC < 0 || xC >= "+i+") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        "+g+"\n        "+x+"\n        setOutput(result);\n      }\n    "},Ot=function(e,n,r,o){void 0===n&&(n=!1),void 0===r&&(r=null),void 0===o&&(o=!1),this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;for(var i=e.inHeight,a=e.inWidth,u=e.padInfo.top,s=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,d=e.dilationHeight,p=e.dilationWidth,h=e.filterHeight,f=e.filterWidth,v=f,x="int xR; int xC; int xCOffset;",g=0;g<h;g++)for(var m=0;m<f;m++)x+="\n          vec4 xTexelR"+g+"C"+2*m+" = vec4(0.);\n          vec4 wR"+g+"C"+m+" = vec4(0.);\n          vec4 xR"+g+"C"+m+" = vec4(0.);";for(g=0;g<h;g++)for(var C=0;C<v;C++){if(x+="\n          xR = xRCorner + "+g*d+";\n          xC = xCCorner + "+(m=2*C)*p+";\n        ",1===c){if(m<f&&(x+=s%2==1?"\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < "+i+" && xCOffset >= 0 && xCOffset < "+a+") {\n                  xTexelR"+g+"C"+m+" = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= "+a+") {\n                    xTexelR"+g+"C"+m+".zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR"+g+"C"+m+" = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < "+i+" && xCOffset >= 0 && xCOffset < "+a+") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= "+a+") {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR"+g+"C"+m+" = vec4(previous.zw, xTexelR"+g+"C"+m+".xy);\n                } else {\n                  xR"+g+"C"+m+" = vec4(0, 0, xTexelR"+g+"C"+m+".xy);\n                }\n              ":"\n                if(xR >= 0 && xR < "+i+" && xC >= 0 && xC < "+a+") {\n                  xTexelR"+g+"C"+m+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+g+"C"+m+" = vec4(0.);\n                }\n\n                xR"+g+"C"+m+" = xTexelR"+g+"C"+m+";\n              ",m+1<f)){var R=s%2==0?t.util.nearestLargerEven(p):p;p%2==0&&s%2==1||p%2!=0&&s%2!=1?(x+="\n                  xCOffset = xC + "+s%2+" + "+R+";\n\n                  if(xR >= 0 && xR < "+i+" &&\n                    xCOffset >= 0 && xCOffset < "+a+") {\n                    xTexelR"+g+"C"+(m+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n                ",p>1&&(x+="\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < "+i+" &&\n                      xCOffset >= 0 && xCOffset < "+a+") {\n                      xTexelR"+g+"C"+m+" = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR"+g+"C"+m+" = vec4(0.);\n                    }\n                  "),x+="\n                  xR"+g+"C"+(m+1)+" = vec4(\n                    xTexelR"+g+"C"+m+".zw, xTexelR"+g+"C"+(m+2)+".xy);\n                "):x+="\n                  xCOffset = xC + "+R+";\n\n                  if(xR >= 0 && xR < "+i+" &&\n                    xCOffset >= 0 && xCOffset < "+a+") {\n                    xTexelR"+g+"C"+(m+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR"+g+"C"+(m+1)+" = xTexelR"+g+"C"+(m+2)+";\n                "}}else m<f&&(x+="\n              if(xR >= 0 && xR < "+i+") {\n            ",s%2==1?(x+="\n                xCOffset = xC + 1 - "+c+";\n                if(xCOffset >= 0 && xCOffset < "+a+") {\n                  xTexelR"+g+"C"+m+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+g+"C"+m+" = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < "+a+") {\n                  xTexelR"+g+"C"+(m+2)+" = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR"+g+"C"+(m+2)+" = vec4(0.);\n                }\n\n                xR"+g+"C"+m+" = vec4(\n                  xTexelR"+g+"C"+m+".zw, xTexelR"+g+"C"+(m+2)+".zw);\n              ",m+1<f&&(x+="\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + "+c+";\n                  if(xCOffset >= 0 && xCOffset < "+a+") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR"+g+"C"+(m+1)+" = vec4(xTexelR"+g+"C"+(m+2)+".xy, final.xy);\n                ")):(x+="\n                if(xC >= 0 && xC < "+a+") {\n                  xTexelR"+g+"C"+m+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+g+"C"+m+" = vec4(0.);\n                }\n\n                xCOffset = xC + "+c+";\n                if(xCOffset >= 0 && xCOffset < "+a+") {\n                  xTexelR"+g+"C"+(m+2)+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+g+"C"+(m+2)+" = vec4(0.);\n                }\n\n                xR"+g+"C"+m+" = vec4(\n                  xTexelR"+g+"C"+m+".xy, xTexelR"+g+"C"+(m+2)+".xy);\n              ",m+1<f&&(x+="\n                  xR"+g+"C"+(m+1)+" = vec4(\n                    xTexelR"+g+"C"+m+".zw, xTexelR"+g+"C"+(m+2)+".zw);\n                ")),x+="}");m<f&&(x+="\n            vec4 wTexelR"+g+"C"+m+" = getW("+g+", "+m+", d1, q);\n            wR"+g+"C"+m+" = vec4(wTexelR"+g+"C"+m+".xz, wTexelR"+g+"C"+m+".xz);\n          ",m+1<f&&(x+="\n              vec4 wTexelR"+g+"C"+(m+1)+" = getW("+g+", "+(m+1)+", d1, q);\n              wR"+g+"C"+(m+1)+" =\n                vec4(wTexelR"+g+"C"+(m+1)+".xz, wTexelR"+g+"C"+(m+1)+".xz);"))}for(g=0;g<h;g++)for(m=0;m<f;m++)x+="dotProd += xR"+g+"C"+m+" * wR"+g+"C"+m+";";var y="",b="";r&&(y=o?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          "+r+"\n        }":"vec4 activation(vec4 x) {\n          "+r+"\n        }",b="result = activation(result);");var w=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+y+"\n\n      const ivec2 strides = ivec2("+l+", "+c+");\n      const ivec2 pads = ivec2("+u+", "+s+");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        "+x+"\n\n        vec4 result = dotProd;\n        "+w+"\n        "+b+"\n        setOutput(result);\n      }\n    "},St=function(e,t,n,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];var i=e[0],a=e[1],u=e[2],s=e[3],l=t[0],c=n[0],d=n[1];this.outputShape=[l,c,d,s];var p="bilinear"===r?1:0,h=[a-1+".0",u-1+".0"],f=h[0],v=h[1],x=c>1?[""+(a-1)/(c-1),"(y2-y1) * height_ratio","y1*"+f+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+f],g=x[0],m=x[1],C=x[2],R=d>1?[""+(u-1)/(d-1),"(x2-x1) * width_ratio","x1*"+v+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+v],y=R[0],b=R[1],w=R[2];this.userCode="\n      const float height_ratio = float("+g+");\n      const float width_ratio = float("+y+");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= "+i+") {\n          return;\n        }\n\n        float height_scale = "+m+";\n        float width_scale = "+b+";\n\n        float in_y = "+C+";\n        if( in_y < 0.0 || in_y > "+f+" ) {\n          setOutput(float("+o+"));\n          return;\n        }\n        float in_x = "+w+";\n        if( in_x < 0.0 || in_x > "+v+" ) {\n          setOutput(float("+o+"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if("+p+" == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    "},Nt=function(){function e(e,t,n){this.variableNames=["x"],this.outputShape=e;var r=e.length,o=t?"0.0":"getX("+Ft(r,"coords")+")",i=e[e.length-1],a="",u="";t?(a=n?"end != "+(i-1):"end != 0",u=n?"end + 1":"end - 1"):(a=n?"end + pow2 < "+i:"end >= pow2",u=n?"end + pow2":"end - pow2"),this.userCode="\n      uniform float index;\n      void main() {\n        "+Je(r)+" coords = getOutputCoords();\n        int end = "+Dt(r,"coords")+";\n        float val = "+o+";\n        int pow2 = int(pow(2.0, index));\n        if ("+a+") {\n          int idx = "+u+";\n          "+Dt(r,"coords")+" = idx;\n          val += getX("+Ft(r,"coords")+");\n        }\n        setOutput(val);\n      }\n    "}return e.prototype.getCustomSetupFunc=function(e){var t=this;return function(n,r){null==t.index&&(t.index=n.getUniformLocation(r,"index")),n.gl.uniform1f(t.index,e)}},e}();function Ft(e,t){if(1===e)return""+t;if(2===e)return t+".x, "+t+".y";if(3===e)return t+".x, "+t+".y, "+t+".z";if(4===e)return t+".x, "+t+".y, "+t+".z, "+t+".w";throw Error("Cumulative sum for rank "+e+" is not yet supported")}function Dt(e,t){if(1===e)return""+t;if(2===e)return t+".y";if(3===e)return t+".z";if(4===e)return t+".w";throw Error("Cumulative sum for rank "+e+" is not yet supported")}var kt=function(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=i.DENSE;var t=h(e),n=Ve();this.outputShape=e,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+Me(["r","c","d"],e)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2("+t[0]+", "+t[1]+"));\n        int index = 4 * (resTexRC.x * "+t[1]+" + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        "+n.output+" = result;\n      }\n    "},Bt=function(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=i.DENSE;var t=h(e),n=Ve();this.outputShape=e,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+Me(["r","c","d"],e)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2("+t[0]+", "+t[1]+"));\n        int index = 4 * (resTexRC.x * "+t[1]+" + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        "+n.output+" = result;\n      }\n    "},Pt=function(){function e(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = "+this.getHeightCoordString()+";\n      int w = "+this.getWidthCoordString()+";\n      int d = "+this.getDepthCoordString()+";\n\n      int in_h = h / "+t+";\n      int offset_h = imod(h, "+t+");\n      int in_w = w / "+t+";\n      int offset_w = imod(w, "+t+");\n      int offset_d = (offset_h * "+t+" + offset_w) *\n        "+this.getOutputDepthSize()+";\n      int in_d = d + offset_d;\n\n      float result = "+this.getInputSamplingString()+";\n      setOutput(result);\n    }\n  "}return e.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},e.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},e.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},e.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]},e.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},e}(),Lt=function(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "},Vt=function(e){this.variableNames=["A"],this.outTexUsage=a.DOWNLOAD;var t=Ve();this.outputShape=e,this.userCode="\n      "+Ue+"\n\n      void main() {\n        float x = getAAtOutCoords();\n        "+t.output+" = encode_float(x);\n      }\n    "},Mt=function(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=a.DOWNLOAD;var t=Ve();this.outputShape=e,this.userCode="\n      "+Ue+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        "+t.output+" = encode_float(x);\n      }\n    "},Wt=function(e,t,n){void 0===n&&(n=!1),this.variableNames=["A"];var r=Ve(),o=t[0],i=t[1];this.outputShape=e;var a="result";n&&(a="floor(result * 255. + 0.5)"),this.userCode="\n      "+We(e)+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / "+i+";\n        int c = imod(flatIndex, "+i+");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2("+i+".0, "+o+".0);\n        vec4 values = "+r.texture2D+"(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        "+r.output+" = vec4("+a+", 0., 0., 0.);\n      }\n    "},Ut=function(e,t,n){void 0===n&&(n=!1),this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var r=Ve(),o=t[0],i=t[1];this.outputShape=e;var a="",u="result";n&&(u="floor(result * 255. + 0.5)");for(var s=0;s<=1;s++)for(var l=0;l<=1;l++){var c=2*s+l;a+="\n          localCoords = coords;\n          if(localCoords[2] + "+l+" < "+e[2]+") {\n            localCoords[2] += "+l+";\n            if(localCoords[1] + "+s+" < "+e[1]+") {\n              localCoords[1] += "+s+";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / "+i+";\n              c = imod(flatIndex, "+i+");\n              uv = (vec2(c, r) + halfCR) / vec2("+i+".0, "+o+".0);\n              values = "+r.texture2D+"(A, uv);\n\n              if(offset == 0) {\n                result["+c+"] = values[0];\n              } else if(offset == 1) {\n                result["+c+"] = values[1];\n              } else if(offset == 2) {\n                result["+c+"] = values[2];\n              } else {\n                result["+c+"] = values[3];\n              }\n            }\n          }\n        "}this.userCode="\n      "+We(e)+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        "+a+"\n\n        "+r.output+" = "+u+";\n      }\n    "},Gt="return real * expR - imag * expI;",zt="return real * expI + imag * expR;",Xt=function(e,t,n){this.variableNames=["real","imag"];var r=t[1];this.outputShape=t;var o=n?"2.0 * "+Math.PI:"-2.0 * "+Math.PI,i=n?r+".0":"1.0";this.userCode="\n      const float exponentMultiplier = "+o+";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        "+e+"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float("+r+");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < "+r+"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / "+i+";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "},Ht=function(){function e(e,t){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}return e.prototype.getCustomSetupFunc=function(e){var t=this;return function(n,r){null==t.valueLoc&&(t.valueLoc=n.getUniformLocationNoThrow(r,"value")),n.gl.uniform1f(t.valueLoc,e)}},e}(),jt=function(e,t,n){this.variableNames=["A","indices"];var r=e.slice();r[n]=t,this.outputShape=r,this.rank=r.length;var o=Je(this.rank),i=function(e,t){var n=e.length;if(n>4)throw Error("Gather for rank "+n+" is not yet supported");if(1===n)return"int(getIndices(resRC))";for(var r=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],i=0;i<e.length;i++)i===t?o.push("int(getIndices("+r[i]+"))"):o.push(""+r[i]);return o.join()}(e,n);this.userCode="\n      void main() {\n        "+o+" resRC = getOutputCoords();\n        setOutput(getA("+i+"));\n      }\n    "};var Kt=function(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;var r=Je(t.length),o=Je(n.length),i=this.sliceDim>1?"strides[j]":"strides";this.userCode="\n        "+r+" strides = "+r+"("+this.strides+");\n         void main() {\n          "+o+" coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < "+this.sliceDim+"; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * "+i+";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "};function Yt(e){var t=Ve();return R(e,t.version+"\n    precision highp float;\n    "+t.attribute+" vec3 clipSpacePos;\n    "+t.attribute+" vec2 uv;\n    "+t.varyingVs+" vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")}function qt(e){return _(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function Qt(e){return O(e,new Uint16Array([0,1,2,2,1,3]))}function Zt(e,t,n,r,o,i){N(t,n);var a=S(e),u=e.TEXTURE_2D;return x(e,(function(){return e.bindTexture(u,a)})),x(e,(function(){return e.texParameteri(u,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)})),x(e,(function(){return e.texParameteri(u,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)})),x(e,(function(){return e.texParameteri(u,e.TEXTURE_MIN_FILTER,e.NEAREST)})),x(e,(function(){return e.texParameteri(u,e.TEXTURE_MAG_FILTER,e.NEAREST)})),x(e,(function(){return e.texImage2D(u,0,r,t,n,0,o,i,null)})),x(e,(function(){return e.bindTexture(e.TEXTURE_2D,null)})),a}function Jt(e){return e.internalFormatFloat}function $t(e,t,n,r){var o=p(t,n);return Zt(e,o[0],o[1],Jt(r),r.textureFormatFloat,e.FLOAT)}function en(e){return e.internalFormatHalfFloat}function tn(e,t,n,r){var o=p(t,n);return Zt(e,o[0],o[1],en(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function nn(e){return e.downloadTextureFormat}function rn(e,t,n,r){var o=p(t,n);return Zt(e,o[0],o[1],nn(r),e.RGBA,e.UNSIGNED_BYTE)}function on(e){return e.internalFormatPackedFloat}function an(e,t,n,r){var o=f(t,n);return Zt(e,o[0],o[1],on(r),e.RGBA,e.FLOAT)}function un(e){return e.internalFormatPackedHalfFloat}function sn(e,t,n,r){var o=f(t,n);return Zt(e,o[0],o[1],un(r),e.RGBA,r.textureTypeHalfFloat)}function ln(e,t,n){return x(e,(function(){return e.bindBuffer(e.ARRAY_BUFFER,n)})),D(e,t,"clipSpacePos",n,3,20,0)&&D(e,t,"uv",n,2,20,12)}function cn(e,t,n,r,o,i){var a,u,s;x(e,(function(){return e.bindTexture(e.TEXTURE_2D,t)})),o instanceof Uint8Array?(a=new Uint8Array(n*r*4),u=e.UNSIGNED_BYTE,s=e.RGBA):(a=new Float32Array(n*r*4),u=e.FLOAT,s=i.internalFormatPackedFloat),a.set(o),x(e,(function(){return e.texImage2D(e.TEXTURE_2D,0,s,n,r,0,e.RGBA,u,a)})),x(e,(function(){return e.bindTexture(e.TEXTURE_2D,null)}))}function dn(e,t,n){x(e,(function(){return e.bindTexture(e.TEXTURE_2D,t)})),n.data instanceof Uint8Array?x(e,(function(){return e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)})):x(e,(function(){return e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)})),x(e,(function(){return e.bindTexture(e.TEXTURE_2D,null)}))}function pn(e,t,n,r){var o=e.createBuffer();x(e,(function(){return e.bindBuffer(e.PIXEL_PACK_BUFFER,o)}));var i=16*t*n;return x(e,(function(){return e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ)})),x(e,(function(){return e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)})),x(e,(function(){return e.bindBuffer(e.PIXEL_PACK_BUFFER,null)})),o}function hn(e,t,n){var r=e,o=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,o),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),o}function fn(e,t,n,r){var o=p(t,n),i=o[0],a=o[1],u=new Uint8Array(t*n*4);return x(e,(function(){return e.readPixels(0,0,i,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,u)})),new Float32Array(u.buffer)}function vn(e,t,n,r,o,i,a,u){var s=e,l=new Float32Array(function(e,t){var n=f(e,t);return n[0]*n[1]*4}(i,a));return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,l),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),l}function xn(e,t,n){var r=new Float32Array(t*n*4);return x(e,(function(){return e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)})),r}var gn={__proto__:null,createVertexShader:Yt,createVertexBuffer:qt,createIndexBuffer:Qt,getInternalFormatForFloat32MatrixTexture:Jt,createFloat32MatrixTexture:$t,getInternalFormatForFloat16MatrixTexture:en,createFloat16MatrixTexture:tn,getInternalFormatForUnsignedBytesMatrixTexture:nn,createUnsignedBytesMatrixTexture:rn,getInternalFormatForPackedMatrixTexture:on,createPackedMatrixTexture:an,getInternalFormatForFloat16PackedMatrixTexture:un,createFloat16PackedMatrixTexture:sn,bindVertexProgramAttributeStreams:ln,uploadDenseMatrixToTexture:cn,uploadPixelDataToTexture:dn,createBufferFromOutputTexture:pn,downloadFloat32MatrixFromBuffer:hn,downloadByteEncodedFloatMatrixFromOutputTexture:fn,downloadPackedMatrixFromBuffer:vn,downloadMatrixFromPackedOutputTexture:xn},mn=function(){function e(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];var n=t.env().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,c(n,e)):this.gl=d(n);var r="WEBGL_color_buffer_float";if(1===t.env().getNumber("WEBGL_VERSION")){if(this.textureFloatExtension=C(this.gl,"OES_texture_float"),$(this.gl,"OES_texture_half_float"))this.textureHalfFloatExtension=C(this.gl,"OES_texture_half_float");else if(t.env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),$(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=C(this.gl,"EXT_color_buffer_half_float");else if(t.env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",$(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!$(this.gl,"EXT_color_buffer_half_float"))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=qt(this.gl),this.indexBuffer=Qt(this.gl),this.framebuffer=F(this.gl),this.textureConfig=v(this.gl,this.textureHalfFloatExtension)}return Object.defineProperty(e.prototype,"debug",{get:function(){return t.env().getBool("DEBUG")},enumerable:!0,configurable:!0}),e.prototype.dispose=function(){var e=this;if(!this.disposed){null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");var t=this.gl;x(t,(function(){return t.finish()})),x(t,(function(){return t.bindFramebuffer(t.FRAMEBUFFER,null)})),x(t,(function(){return t.deleteFramebuffer(e.framebuffer)})),x(t,(function(){return t.bindBuffer(t.ARRAY_BUFFER,null)})),x(t,(function(){return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)})),x(t,(function(){return t.deleteBuffer(e.indexBuffer)})),this.disposed=!0}},e.prototype.createFloat32MatrixTexture=function(e,t){return this.throwIfDisposed(),$t(this.gl,e,t,this.textureConfig)},e.prototype.createFloat16MatrixTexture=function(e,t){return this.throwIfDisposed(),tn(this.gl,e,t,this.textureConfig)},e.prototype.createUnsignedBytesMatrixTexture=function(e,t){return this.throwIfDisposed(),rn(this.gl,e,t,this.textureConfig)},e.prototype.uploadPixelDataToTexture=function(e,t){this.throwIfDisposed(),dn(this.gl,e,t)},e.prototype.uploadDenseMatrixToTexture=function(e,t,n,r){this.throwIfDisposed(),cn(this.gl,e,t,n,r,this.textureConfig)},e.prototype.createFloat16PackedMatrixTexture=function(e,t){return this.throwIfDisposed(),sn(this.gl,e,t,this.textureConfig)},e.prototype.createPackedMatrixTexture=function(e,t){return this.throwIfDisposed(),an(this.gl,e,t,this.textureConfig)},e.prototype.deleteMatrixTexture=function(e){var t=this;this.throwIfDisposed(),this.outputTexture===e&&(M(this.gl,this.framebuffer),this.outputTexture=null),x(this.gl,(function(){return t.gl.deleteTexture(e)}))},e.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(e,t,n){var r=this;return this.downloadMatrixDriver(e,(function(){return fn(r.gl,t,n,r.textureConfig)}))},e.prototype.downloadPackedMatrixFromBuffer=function(e,t,n,r,o,i){return vn(this.gl,e,0,0,0,o,i,this.textureConfig)},e.prototype.downloadFloat32MatrixFromBuffer=function(e,t){return hn(this.gl,e,t)},e.prototype.createBufferFromTexture=function(e,t,n){this.bindTextureToFrameBuffer(e);var r=pn(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r},e.prototype.createAndWaitForFence=function(){var e=this.createFence(this.gl);return this.pollFence(e)},e.prototype.createFence=function(e){var n,r,o=this;if(t.env().getBool("WEBGL_FENCE_API_ENABLED")){var i=e,a=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=function(){var e=i.clientWaitSync(a,0,0);return e===i.ALREADY_SIGNALED||e===i.CONDITION_SATISFIED},n=a}else t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=function(){return o.isQueryAvailable(n,t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):r=function(){return!0};return{query:n,isFencePassed:r}},e.prototype.downloadMatrixFromPackedTexture=function(e,t,n){var r=this;return this.downloadMatrixDriver(e,(function(){return xn(r.gl,t,n)}))},e.prototype.createProgram=function(e){this.throwIfDisposed();var t=this.gl,n=y(t,e),r=Yt(t),o=A(t);return x(t,(function(){return t.attachShader(o,r)})),x(t,(function(){return t.attachShader(o,n)})),I(t,o),this.debug&&T(t,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=ln(t,this.program,this.vertexBuffer)),o},e.prototype.deleteProgram=function(e){var t=this;this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&x(this.gl,(function(){return t.gl.deleteProgram(e)}))},e.prototype.setProgram=function(e){var t=this;this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&T(this.gl,this.program),x(this.gl,(function(){return t.gl.useProgram(e)}))},e.prototype.getUniformLocation=function(e,t,n){return void 0===n&&(n=!0),this.throwIfDisposed(),n?B(this.gl,e,t):P(this.gl,e,t)},e.prototype.getAttributeLocation=function(e,t){var n=this;return this.throwIfDisposed(),x(this.gl,(function(){return n.gl.getAttribLocation(e,t)}))},e.prototype.getUniformLocationNoThrow=function(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)},e.prototype.setInputMatrixTexture=function(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),L(this.gl,e,t,n)},e.prototype.setOutputMatrixTexture=function(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)},e.prototype.setOutputPackedMatrixTexture=function(e,t,n){this.throwIfDisposed();var r=f(t,n),o=r[0],i=r[1];this.setOutputMatrixTextureDriver(e,o,i)},e.prototype.setOutputMatrixWriteRegion=function(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)},e.prototype.setOutputPackedMatrixWriteRegion=function(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")},e.prototype.debugValidate=function(){null!=this.program&&T(this.gl,this.program),W(this.gl)},e.prototype.executeProgram=function(){this.throwIfDisposed(),this.throwIfNoProgram();var e=this.gl;this.debug&&this.debugValidate(),x(e,(function(){return e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)}))},e.prototype.blockUntilAllProgramsCompleted=function(){var e=this;this.throwIfDisposed(),x(this.gl,(function(){return e.gl.finish()}))},e.prototype.getQueryTimerExtension=function(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=C(this.gl,2===t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension},e.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()},e.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()},e.prototype.beginQuery=function(){if(2===t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var e=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=e.createQuery();return e.beginQuery(n.TIME_ELAPSED_EXT,r),r}var o=this.getQueryTimerExtensionWebGL1(),i=o.createQueryEXT();return o.beginQueryEXT(o.TIME_ELAPSED_EXT,i),i},e.prototype.endQuery=function(){if(2!==t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}else{var n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT)}},e.prototype.waitForQueryAndGetTime=function(e){return r(this,void 0,void 0,(function(){var n=this;return o(this,(function(r){switch(r.label){case 0:return[4,t.util.repeatedTry((function(){return n.disposed||n.isQueryAvailable(e,t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}))];case 1:return r.sent(),[2,this.getQueryTime(e,t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]}}))}))},e.prototype.getQueryTime=function(e,t){if(0===t)return null;if(2===t){var n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}var r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6},e.prototype.isQueryAvailable=function(e,t){if(0===t)return!0;if(2===t){var n=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}o=(r=this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint},e.prototype.pollFence=function(e){var t=this;return new Promise((function(n){t.addItemToPoll((function(){return e.isFencePassed()}),(function(){return n()}))}))},e.prototype.pollItems=function(){for(var e=function(e){for(var t=0;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((function(e){return e.isDoneFn}))),t=0;t<=e;++t){(0,this.itemsToPoll[t].resolveFn)()}this.itemsToPoll=this.itemsToPoll.slice(e+1)},e.prototype.addItemToPoll=function(e,n){var r=this;this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1||t.util.repeatedTry((function(){return r.pollItems(),0===r.itemsToPoll.length}))},e.prototype.bindTextureToFrameBuffer=function(e){this.throwIfDisposed(),V(this.gl,e,this.framebuffer),this.debug&&W(this.gl)},e.prototype.unbindTextureToFrameBuffer=function(){null!=this.outputTexture?(V(this.gl,this.outputTexture,this.framebuffer),this.debug&&W(this.gl)):M(this.gl,this.framebuffer)},e.prototype.downloadMatrixDriver=function(e,t){this.bindTextureToFrameBuffer(e);var n=t();return this.unbindTextureToFrameBuffer(),n},e.prototype.setOutputMatrixTextureDriver=function(e,t,n){this.throwIfDisposed();var r=this.gl;V(r,e,this.framebuffer),this.debug&&W(r),this.outputTexture=e,x(r,(function(){return r.viewport(0,0,t,n)})),x(r,(function(){return r.scissor(0,0,t,n)}))},e.prototype.setOutputMatrixWriteRegionDriver=function(e,t,n,r){var o=this;this.throwIfDisposed(),x(this.gl,(function(){return o.gl.scissor(e,t,n,r)}))},e.prototype.throwIfDisposed=function(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")},e.prototype.throwIfNoProgram=function(){if(null==this.program)throw new Error("No GPU program is currently set.")},e}();function Cn(e,n){if(e.length!==n.length)throw Error("Binary was compiled with "+e.length+" inputs, but was executed with "+n.length+" inputs");e.forEach((function(e,r){var o=e.logicalShape,i=n[r],a=i.shape;if(!t.util.arraysEqual(o,a))throw Error("Binary was compiled with different shapes than the current args. Shapes "+o+" and "+a+" must match");if(!e.isUniform||!i.isUniform){var u=e.texShape,s=i.isUniform?null:i.texData.texShape;if(!t.util.arraysEqual(u,s))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+u+" and "+s+" must match")}}))}var Rn=function(e,t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;for(var r=n.filterWidth,o=n.inChannels,i=n.strideWidth,a=n.strideHeight,u=n.padInfo,s=n.outWidth,l=n.dilationWidth,c=n.dilationHeight,d=n.dataFormat,p=u.left,h=u.top,f=o*r,v=Ve(),x="channelsLast"===d,g=x?0:1,m=x?1:2,C="",R=0;R<=1;R++)for(var y=0;y<=1;y++)C+="\n          blockIndex = rc.y + "+y+";\n          pos = rc.x + "+R+";\n\n          if(blockIndex < "+e[1]+" && pos < "+e[0]+") {\n            offsetY = int(blockIndex / ("+s+")) * "+a+" - "+h+";\n            d0 = offsetY + "+c+" * (pos / "+f+");\n\n            if(d0 < "+t[g]+" && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), "+s+".) * "+i+". - "+p+".);\n              d1 = offsetX + "+l+" * (int(mod(float(pos), "+f+".) / "+o+".));\n\n              if(d1 < "+t[m]+" && d1 >= 0) {\n\n                ch = int(mod(float(pos), "+o+".));\n\n                if ("+x+") {\n                  innerDims = vec2(d1, ch);\n                  result["+(2*R+y)+"] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result["+(2*R+y)+"] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";this.userCode="\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        "+C+"\n\n        "+v.output+" = result;\n      }\n    "},yn=function(e,t,n,r,o){this.variableNames=["x"],this.outputShape=[];var i,a=t,u=e[3]-1;this.outputShape=e;var s="float("+n+") + float("+r+") * sum";i=.5===o?"inversesqrt("+s+")":1===o?"1.0/("+s+")":"exp(log("+s+") * float(-"+o+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -"+a+"; j <= "+a+"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  "+u+") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * "+i+";\n        setOutput(val);\n      }\n    "},bn=function(e,t,n,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=o,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < "+this.depth+"; ++d) {\n          int depthBegin = int(max(0.0, float(d - "+t+")));\n          int depthEnd = int(min(float("+this.depth+"),\n              float(d + "+t+" + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = "+this.depth+";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float("+r+") * norm + float("+n+");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float("+r+")\n                * float("+o+")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * "+o+");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "},wn=function(e,t,n,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;var i,a=t,u=e[3]-1;this.outputShape=e;var s="float("+n+") + float("+r+") * sum";i=.5===o?"inversesqrt("+s+")":1===o?"1.0/("+s+")":"exp(log("+s+") * float(-"+o+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < "+this.outputShape[3]+";\n        bool hasNextRow = c < "+this.outputShape[2]+";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - "+a+";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - "+a+"; j <= "+a+"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2("+u+"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * "+i+";\n        setOutput(result);\n      }\n    "},En=function(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;var t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,o=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=o-1-e.padInfo.top,u=i-1-e.padInfo.left,s=o*i-1;this.userCode="\n      const ivec2 pads = ivec2("+a+", "+u+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+o+";\n          wR += "+r+") {\n          float dyR = float(dyRCorner + wR) / "+t+".0;\n\n          if (dyR < 0.0 || dyR >= "+e.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+i+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+n+".0;\n\n            if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = "+s+" - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * "+i+" + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},An=function(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;var t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterDepth,s=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=u-1-e.padInfo.front,d=s-1-e.padInfo.top,p=l-1-e.padInfo.left,h=u*s*l-1;this.userCode="\n      const ivec3 pads = ivec3("+c+", "+d+", "+p+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < "+u+";\n           wD += "+o+") {\n          float dyD = float(dyDCorner + wD) / "+t+".0;\n\n          if (dyD < 0.0 || dyD >= "+e.outDepth+".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < "+s+";\n              wR += "+i+") {\n            float dyR = float(dyRCorner + wR) / "+n+".0;\n\n            if (dyR < 0.0 || dyR >= "+e.outHeight+".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < "+l+";\n                wC += "+a+") {\n              float dyC = float(dyCCorner + wC) / "+r+".0;\n\n              if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = "+h+" -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * "+s+" * "+l+" +\n                  wR * "+l+" + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},In=function(e,t,n,r,o,i,a){void 0===n&&(n=!1),void 0===r&&(r=!1),void 0===o&&(o=!1),void 0===i&&(i=null),void 0===a&&(a=!1),this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;var u=n?e[1]:e[2],s=Math.ceil(u/2),l=n?"i * 2, rc.y":"rc.y, i * 2",c=r?"rc.z, i * 2":"i * 2, rc.z",d=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],p=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],h="",f="";i&&(h=a?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          "+i+"\n        }":"vec4 activation(vec4 x) {\n          "+i+"\n        }",f="result = activation(result);");var v=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+h+"\n\n      const float sharedDimension = "+s+".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < "+s+"; i++) {\n          vec4 a = getMatrixA(rc.x, "+l+");\n          vec4 b = getMatrixB(rc.x, "+c+");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += ("+d[0]+" * "+p[0]+");\n          result += ("+d[1]+" * "+p[1]+");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        "+v+"\n\n        "+f+"\n\n        setOutput(result);\n      }\n    "},Tn=function(){function e(e,t,n){this.variableNames=["probs"],this.outputShape=[e,n],this.userCode="\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < "+(t-1)+"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float("+(t-1)+"));\n      }\n    "}return e.prototype.getCustomSetupFunc=function(e){var t=this;return function(n,r){null==t.seedLoc&&(t.seedLoc=n.getUniformLocation(r,"seed")),n.gl.uniform1f(t.seedLoc,e)}},e}(),_n=function(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float("+r+"), float("+n+"),\n                      float(index == coords.y)));\n      }\n    "},On=function(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;var t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{var n=Le("rc",t),r=Je(t),o=function(e,t,n){if(1===e)return"rc > "+t[0];for(var r="",o=e-2;o<e;o++)r+=n[o]+" >= "+t[o],o<e-1&&(r+="||");return r}(t,e,n),i=function(e,t,n,r){if(1===e)return"";var o=r.slice(-2);return"\n    int r = "+o[0]+";\n    int c = "+o[1]+";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= "+t+";\n    bool rEdge = rp1 >= "+n+";\n  "}(t,e[e.length-1],e[e.length-2],n),a=function(e,t){var n=e.length,r=function(e,t){for(var n=[],r=0;r<=1;r++)for(var o=0;o<=1;o++){for(var i=(0===r?"r":"rp1")+", "+(0===o?"c":"cp1"),a=2;a<e;a++)i=t[t.length-1-a]+","+i;n.push(i)}return n}(n,t);return 1===n?"getA(rc),\n            rc + 1 >= "+e[0]+" ? 0. : getA(rc + 1),\n            0, 0":"getA("+r[0]+"),\n          cEdge ? 0. : getA("+r[1]+"),\n          rEdge ? 0. : getA("+r[2]+"),\n          rEdge || cEdge ? 0. : getA("+r[3]+")"}(e,n);this.userCode="\n        void main() {\n          "+r+" rc = getOutputCoords();\n\n          if("+o+") {\n            setOutput(vec4(0));\n          } else {\n            "+i+"\n\n            setOutput(vec4("+a+"));\n          }\n        }\n      "}};var Sn=function(e,t,n){this.variableNames=["x"],this.outputShape=t.map((function(t,n){return t[0]+e[n]+t[1]}));var r=e.length,o=Je(r),i=t.map((function(e){return e[0]})).join(","),a=t.map((function(t,n){return t[0]+e[n]})).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?"\n      "+o+" start = "+o+"("+i+");\n      "+o+" end = "+o+"("+a+");\n\n      void main() {\n        "+o+" outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float("+n+"));\n        } else {\n          "+o+" coords = outC - start;\n          setOutput(getX("+u+"));\n        }\n      }\n    ":"\n        int start = "+i+";\n        int end = "+a+";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float("+n+"));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      "},Nn=function(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((function(t,n){return t[0]+e[n]+t[1]}));for(var r=e.length,o=Je(r),i=t.map((function(e){return e[0]})).join(","),a=t.map((function(t,n){return t[0]+e[n]})).join(","),u=Le("rc",r),s=Le("source",r),l=u[r-1]+" < "+this.outputShape[r-1],c=1===r?"source":"vec2("+s.slice(-2).join()+")",d=[o+" rc = outputLoc;",u[r-1]+" += 1;\n       if("+l+") {\n      ",1===r?"":"}\n       rc = outputLoc;\n       "+u[r-2]+" += 1;\n       if("+u[r-2]+" < "+this.outputShape[r-2]+") {",1===r?"":"  "+u[r-1]+" += 1;\n         if("+l+") {"],p=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="",f=0,v=1===r?2:4;f<v;f++)h+="\n        "+d[f]+"\n        if ("+p+") {\n          result["+f+"] = float("+n+");\n        } else {\n          "+o+" source = rc - start;\n          result["+f+"] = getChannel(getX("+s.join()+"), "+c+");\n        }\n      ";h+=1===r?"} ":"}}",this.userCode="\n      const "+o+" start = "+o+"("+i+");\n      const "+o+" end = "+o+"("+a+");\n\n      void main() {\n        "+o+" outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        "+h+"\n        setOutput(result);\n      }\n    "},Fn=function(e,t,n,r,o){if(void 0===r&&(r=!1),void 0===o&&(o=!1),this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");var i=e.filterWidth,a=e.strideHeight,u=e.strideWidth,s=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;var f="avg"===t,v="((batch  * "+e.inHeight+" + xR) * "+e.inWidth+" + xC) * "+e.inChannels+" + d",x="(xR * "+e.inWidth+" + xC) * "+e.inChannels+" + d",g="0.0";if(f||(g="-1.0 / 1e-20"),n)this.userCode="\n        const ivec2 strides = ivec2("+a+", "+u+");\n        const ivec2 pads = ivec2("+p+", "+h+");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < "+c+";\n              wR += "+s+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+e.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+d+";\n                wC += "+l+") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= "+e.inWidth+") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = "+(r?o?v:x:"wR * "+d+" + wC")+";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else{var m=t+"("+t+"("+t+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(m="avgValue / count");var C=4*Math.floor(i/4),R=i%4,y="\n      if ("+f+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec2 strides = ivec2("+a+", "+u+");\n      const ivec2 pads = ivec2("+p+", "+h+");\n      const float initializationValue = "+g+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= "+e.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+g+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < "+c+";\n            wR += "+s+") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+e.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+C+"; wC += 4) {\n            int xC = xCCorner + wC * "+l+";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+l+", d),\n              getValue(batch, xR, xC + 2 * "+l+", d),\n              getValue(batch, xR, xC + 3 * "+l+", d)\n            );\n\n            "+y+"\n          }\n\n          int xC = xCCorner + "+C+";\n          if ("+(1===R)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            "+y+"\n          } else if ("+(2===R)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+l+", d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+y+"\n          } else if ("+(3===R)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+l+", d),\n              getValue(batch, xR, xC + 2 * "+l+", d),\n              initializationValue\n            );\n\n            "+y+"\n          }\n        }\n        setOutput("+m+");\n      }\n    "}},Dn=function(e,t,n,r,o){if(void 0===r&&(r=!1),void 0===o&&(o=!1),this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");var i=e.filterWidth,a=e.strideDepth,u=e.strideHeight,s=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,v=e.padInfo.front,x=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;var m="avg"===t,C="0.0";if(m||(C="-1.0 / 1e-20"),n)this.userCode="\n        const ivec3 strides =\n            ivec3("+a+", "+u+", "+s+");\n        const ivec3 pads = ivec3("+v+", "+x+", "+g+");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < "+p+";\n              wD += "+l+") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= "+e.inDepth+") {\n              continue;\n            }\n\n            for (int wR = 0; wR < "+h+";\n                wR += "+c+") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= "+e.inHeight+") {\n                continue;\n              }\n\n              for (int wC = 0; wC < "+f+";\n                  wC += "+d+") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= "+e.inWidth+") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = "+(r?o?"(((batch * "+e.inDepth+" + xD) * "+e.inHeight+" + xR) * "+e.inWidth+" + xC) * "+e.inChannels+" + ch":"((xD * "+e.inHeight+" + xR) * "+e.inWidth+" + xC) * "+e.inChannels+" + ch":"wD * "+h+" * "+f+" +\n                      wR * "+f+" + wC")+";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else{var R=t+"("+t+"("+t+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(R="avgValue / count");var y=4*Math.floor(i/4),b=i%4,w="\n      if ("+m+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec3 strides =\n        ivec3("+a+", "+u+", "+s+");\n      const ivec3 pads = ivec3("+v+", "+x+", "+g+");\n      const float initializationValue = "+C+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= "+e.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+C+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < "+p+";\n            wD += "+l+") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= "+e.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+h+";\n            wR += "+c+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+e.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+y+"; wC += 4) {\n              int xC = xCCorner + wC * "+d+";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+d+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+d+", ch),\n                getValue(batch, xD, xR, xC + 3 * "+d+", ch)\n              );\n\n              "+w+"\n            }\n\n            int xC = xCCorner + "+y+";\n            if ("+(1===b)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              "+w+"\n            } else if ("+(2===b)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+d+", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              "+w+"\n            } else if ("+(3===b)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+d+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+d+", ch),\n                initializationValue\n              );\n\n              "+w+"\n            }\n          }\n          setOutput("+R+");\n        }\n      }\n    "}},kn=function(e,t){this.variableNames=["x"];var n=e.windowSize,r=e.batchSize,o=e.inSize,i=e.outSize;this.outputShape=[r,i];var a="0.0",u="";"prod"===t?a="1.0":"min"===t?(a="1.0 / 1e-20",u="min"):"max"===t&&(a="-1.0 / 1e-20",u="max");var s=t+"("+t+"("+t+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?s="sumValue":"prod"===t?s="prodValue":"all"===t?s="allValue":"any"===t&&(s="anyValue");var l=4*Math.floor(n/4),c=n%4,d="\n      if ("+("sum"===t)+") {\n        sumValue += dot(values, ones);\n      } else if ("+("prod"===t)+") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = "+u+"(values, minMaxValue);\n      }\n    ",p="vec4";"all"===t?(a="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===t&&(a="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");var h="";o%n>0&&(h="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return initializationValue;\n        }\n      "),this.userCode="\n      const float initializationValue = "+a+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+h+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+n+";\n\n        vec4 minMaxValue = vec4("+a+");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < "+l+"; i += 4) {\n          int inIdx = inOffset + i;\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+d+"\n        }\n\n        int inIdx = inOffset + "+l+";\n        if ("+(1===c)+") {\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          "+d+"\n        } else if ("+(2===c)+") {\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          "+d+"\n        } else if ("+(3===c)+") {\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          "+d+"\n        }\n        setOutput("+s+");\n      }\n    "},Bn=function(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;for(var n="",r=0;r<4;r++){var o="thisRC = rc;";r%2==1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),n+="\n        "+o+"\n        "+(r>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+"\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result["+r+"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        "+(r>0?"}":"")+"\n      "}this.userCode="\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      "+Me(["r","c","d"],t)+"\n      return ivec3(r, c, d);\n    }\n  \n      "+We(e)+"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = "+e[1]+";\n        int cols = "+e[2]+";\n\n        "+n+"\n\n        setOutput(result);\n      }\n    "};var Pn=function(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t.shape;var r=t.shape,o=r[1],i=r[2],a=e.shape,u=a[1],s=a[2],l=[n&&u>1?o-1:o,n&&s>1?i-1:i],c=[n&&u>1?u-1:u,n&&s>1?s-1:s],d=l[0]/c[0],p=l[1]/c[1],h=1/d,f=1/p,v=2*Math.ceil(h)+2,x=2*Math.ceil(f)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+d+");\n        const float widthScale = float("+p+");\n\n        const float invHeightScale = float("+h+");\n        const float invWidthScale = float("+f+");\n\n        const int winHeight = int("+v+");\n        const int winWidth = int("+x+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+u+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+s+") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), "+(o-1)+".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), "+(i-1)+".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "},Ln=function(e,t,n,r){this.variableNames=["A"],this.outputShape=[];var o=e[0],i=e[1],a=e[2],u=e[3];this.outputShape=[o,t,n,u];var s=[r&&t>1?i-1:i,r&&n>1?a-1:a],l=[r&&t>1?t-1:t,r&&n>1?n-1:n];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+s[0]/l[0]+",\n          "+s[1]/l[1]+");\n      const vec2 inputShapeRC = vec2("+i+".0, "+a+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "},Vn=function(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];var o=e[0],i=e[1],a=e[2],u=e[3];this.outputShape=[o,t,n,u];var s=[r&&t>1?i-1:i,r&&n>1?a-1:a],l=[r&&t>1?t-1:t,r&&n>1?n-1:n];this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          "+s[0]/l[0]+",\n          "+s[1]/l[1]+",\n          "+s[1]/l[1]+");\n      const vec3 inputShapeRC = vec3("+i+".0, "+a+".0,\n                                     "+a+".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < "+(u-1)+";\n        bool hasNextRow = coords.z < "+(n-1)+";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    "},Mn=function(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t.shape;var r=t.shape,o=r[1],i=r[2],a=e.shape,u=a[1],s=a[2],l=[n&&u>1?o-1:o,n&&s>1?i-1:i],c=[n&&u>1?u-1:u,n&&s>1?s-1:s],d=l[0]/c[0],p=l[1]/c[1],h=1/d,f=1/p,v=2*Math.ceil(h)+2,x=2*Math.ceil(f)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+d+");\n        const float widthScale = float("+p+");\n\n        const float invHeightScale = float("+h+");\n        const float invWidthScale = float("+f+");\n\n        const int winHeight = int("+v+");\n        const int winWidth = int("+x+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+u+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+s+") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float("+l[0]+") *\n                (float(dyR) / float("+c[0]+"));\n\n            float sourceFracCol =\n                float("+l[1]+") *\n                  (float(dyC) / float("+c[1]+"));\n\n            int sourceNearestRow = int(min(\n                float(int("+o+") - 1),\n                "+n+" ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int("+i+") - 1),\n                "+n+" ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "},Wn=function(e,t,n,r){this.variableNames=["A"],this.outputShape=[];var o=e[0],i=e[1],a=e[2],u=e[3];this.outputShape=[o,t,n,u];var s=[r&&t>1?i-1:i,r&&n>1?a-1:a],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],c=r?"0.5":"0.0";this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+s[0]/l[0]+",\n          "+s[1]/l[1]+");\n      const vec2 inputShapeRC = vec2("+i+".0, "+a+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + "+c+")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "},Un=function(e,t){this.variableNames=["x"];var n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-"+n+" tensor is not yet supported");if(this.outputShape=e,1!==n){var r=e.map((function(n,r){return function(n){return-1!==t.indexOf(n)&&1!==e[n]?e[n]+" - coords["+n+"] - 1":"coords["+n+"]"}(r)})).join(","),o=Je(n);this.userCode="\n      void main() {\n        "+o+" coords = getOutputCoords();\n        setOutput(getX("+r+"));\n      }\n    "}else this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX("+e[0]+" - coord - 1));\n        }\n      "},Gn=function(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;var n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-"+n+" tensor is not yet supported");this.outputShape=e;var r=Le("rc",n),o=r[n-1]+" + 1 < "+this.outputShape[n-1],i=r[n-2]+" + 1 < "+this.outputShape[n-2],a=Je(n);function u(n){var r=e.map((function(r,o){return function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?e[n]+" - "+r[n]+" - 1":""+r[n]}(o,n)}));return"getChannel(getX("+r.join(",")+"), vec2("+r.slice(-2).join(",")+"))"}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX("+e[0]+" - rc - 1),\n            "+e[0]+" - rc - 1);\n          if("+o+"){\n              result.g = getChannel(getX("+e[0]+" - (rc  + 1) - 1),\n                "+e[0]+" - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ":"\n        void main() {\n          "+a+" rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = "+function(e){return u(e)}(r.slice())+";\n          if("+o+"){\n            result.g = "+function(e){return e[n-1]="("+e[n-1]+" + 1)",u(e)}(r.slice())+";\n          }\n          if("+i+") {\n            result.b = "+function(e){return e[n-2]="("+e[n-2]+" + 1)",u(e)}(r.slice())+";\n            if("+o+") {\n              result.a = "+function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",u(e)}(r.slice())+";\n            }\n          }\n          setOutput(result);\n        }\n    "},zn=function(e,t,n,r,o,i,a){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;var u=Je(o.length),s=Je(i.length),l="";1===n?l="i":2===n&&(l="i, j");var c="getIndices("+l+")",d="";1===r?d="i":2===r&&(d="i, coords[1]");var p="getUpdates("+d+")",h=t>1?"strides[j]":"strides";this.userCode="\n        "+u+" strides = "+u+"("+o+");\n\n        void main() {\n          "+s+" coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < "+e+"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < "+t+"; j++) {\n              int index = round("+c+");\n              flattenedIndex += index * "+h+";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += "+p+";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "},Xn=function(e,t){this.variableNames=["x","segmentIds"];var n=e.windowSize,r=e.batchSize,o=e.inSize,i=e.numSegments,a=i*Math.ceil(o/n);this.outputShape=[r,a];var u=4*Math.floor(n/4),s=n%4,l="\n        sumValue += dot(values, segFilter);\n    ",c="";o%n>0&&(c="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return initializationValue;\n        }\n      ");var d="";o%n>0&&(d="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return -1.0;\n        }\n      "),this.userCode="\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        "+c+"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        "+d+"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          "+i+")) * float("+n+"));\n        int currentSeg = int(mod(float(outIdx), float("+i+")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < "+u+"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          "+l+"\n        }\n\n        int inIdx = inOffset + "+u+";\n        if ("+(1===s)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          "+l+"\n        } else if ("+(2===s)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          "+l+"\n        } else if ("+(3===s)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          "+l+"\n        }\n        setOutput(sumValue);\n      }\n    "},Hn=function(e,t,n){var r,o;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error("Where for rank "+n+" is not yet supported");if(1===n)o="resRC",r="resRC";else{for(var i=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],u=[],s=0;s<t.length;s++)u.push(""+i[s]),s<e&&a.push(""+i[s]);r=a.join(),o=u.join()}var l=Je(n);this.userCode="\n      void main() {\n        "+l+" resRC = getOutputCoords();\n        float cVal = getC("+r+");\n        if (cVal >= 1.0) {\n          setOutput(getA("+o+"));\n        } else {\n          setOutput(getB("+o+"));\n        }\n      }\n    "},jn=function(){function e(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;var t,n=Je(this.rank),r="uniform int start["+this.rank+"];",o=function(e){if(1===e)return"sourceLoc";if(e<=6)return Kn.slice(0,e).map((function(e){return"sourceLoc."+e})).join(",");throw Error("Slicing for rank "+e+" is not yet supported")}(this.rank);t="\n        "+n+" sourceLoc;\n        "+n+" coords = getOutputCoords();\n        "+e.map((function(e,t){return"sourceLoc."+Kn[t]+" = start["+t+"] + coords."+Kn[t]+";"})).join("\n")+"\n      ",this.userCode="\n      "+r+"\n      void main() {\n        "+t+"\n        setOutput(getSource("+o+"));\n      }\n    "}return e.prototype.getCustomSetupFunc=function(e){var t=this;if(e.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+e.length+")");return function(n,r){null==t.startLoc&&(t.startLoc=n.getUniformLocationNoThrow(r,"start"),null==t.startLoc)||n.gl.uniform1iv(t.startLoc,e)}},e}(),Kn=["x","y","z","w","u","v"];var Yn=function(){function e(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;var t=Je(this.rank),n=Le("coords",this.rank),r=Le("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":"vec2("+r.slice(-2).join()+")",i="getChannel(getSource("+r.join()+"), "+o+")",a="\n      result.x = "+i+";\n      if (++"+n[this.rank-1]+" < "+e[this.rank-1]+") {\n        ++"+r[this.rank-1]+";\n        result.y = "+i+";\n        --"+r[this.rank-1]+";\n      }\n    ",u=1===this.rank?"":"\n      --"+n[this.rank-1]+";\n      if (++"+n[this.rank-2]+" < "+e[this.rank-2]+") {\n        ++"+r[this.rank-2]+";\n        result.z = "+i+";\n        if (++"+n[this.rank-1]+" < "+e[this.rank-1]+") {\n          ++"+r[this.rank-1]+";\n          result.w = "+i+";\n        }\n      }\n    ",s=this.rank<=4?"sourceLoc = coords +\n            "+t+"("+e.map((function(e,t){return"start["+t+"]"})).join()+");":e.map((function(e,t){return r[t]+" = "+n[t]+" + start["+t+"];"})).join("\n");this.userCode="\n      uniform int start["+this.rank+"];\n      void main() {\n        "+t+" coords = getOutputCoords();\n        "+t+" sourceLoc;\n        "+s+"\n        vec4 result = vec4(0.);\n        "+a+"\n        "+u+"\n        setOutput(result);\n      }\n    "}return e.prototype.getCustomSetupFunc=function(e){var t=this;if(e.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+e.length+")");return function(n,r){null==t.startLoc&&(t.startLoc=n.getUniformLocationNoThrow(r,"start"),null==t.startLoc)||n.gl.uniform1iv(t.startLoc,e)}},e}(),qn=function(e,t,n){this.variableNames=["x"],this.outputShape=n;var r=n.length,o=Je(n.length),i=Je(n.length),a="";if(1===r)a="coords * strides + begin";else{var u=0;a=n.map((function(e,t){return u++,1===n.length?"coords * strides["+t+"] + begin["+t+"]":"coords["+(u-1)+"] * strides["+t+"] + begin["+t+"]"})).join(",")}this.userCode="\n      "+o+" begin = "+o+"("+e+");\n      "+o+" strides = "+o+"("+t+");\n\n      void main() {\n        "+i+" coords = getOutputCoords();\n        setOutput(getX("+a+"));\n      }\n    "},Qn=function(){function e(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}return e.prototype.acquireTexture=function(e,t,n){var r=Jn(t,n),o=$n(e,r,n);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);var i,a=Zn(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();var s=this.freeTextures[o].shift();return this.usedTextures[o].push(s),s}return r===u.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===u.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===u.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===u.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===u.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i},e.prototype.releaseTexture=function(e,n,r,o){if(null!=this.freeTextures){var i=Jn(r,o),a=$n(n,i,o);a in this.freeTextures||(this.freeTextures[a]=[]);var u=Zn(n,i,this.gpgpu.gl,this.gpgpu.textureConfig,o),s=t.env().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==s&&this._numBytesAllocated>s?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=u):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=u),this.numUsedTextures--;var l=this.usedTextures[a],c=l.indexOf(e);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}},e.prototype.log=function(){if(this.logEnabled){var e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+e+")");var t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: "+this._numBytesAllocated),console.log("Bytes unused: "+this._numBytesFree+" ("+Math.round(100*t)+"%)")}},Object.defineProperty(e.prototype,"numBytesAllocated",{get:function(){return this._numBytesAllocated},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"numBytesFree",{get:function(){return this._numBytesFree},enumerable:!0,configurable:!0}),e.prototype.getNumUsedTextures=function(){return this.numUsedTextures},e.prototype.getNumFreeTextures=function(){return this.numFreeTextures},e.prototype.dispose=function(){var e=this;if(null!=this.freeTextures){for(var t in this.freeTextures)this.freeTextures[t].forEach((function(t){e.gpgpu.deleteMatrixTexture(t)}));for(var t in this.usedTextures)this.usedTextures[t].forEach((function(t){e.gpgpu.deleteMatrixTexture(t)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}},e}();function Zn(e,t,n,r,o){var i,a=function(e,t){switch(e){case u.PACKED_2X2_FLOAT32:return on(t);case u.PACKED_2X2_FLOAT16:return un(t);case u.UNPACKED_FLOAT32:return Jt(t);case u.UNPACKED_FLOAT16:return en(t);case u.PACKED_4X1_UNSIGNED_BYTE:return nn(t);default:throw new Error("Unknown physical texture type "+e)}}(t,r);if(o){var s=f(e[0],e[1]);i=s[0]*s[1]}else{var l=p(e[0],e[1]);i=l[0]*l[1]}return i*function(e,t){var n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;throw new Error("Unknown internal format "+t)}(n,a)}function Jn(e,n){if(e===a.UPLOAD)return u.PACKED_2X2_FLOAT32;if(e===a.RENDER||null==e)return function(e){return t.env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?u.PACKED_2X2_FLOAT32:u.UNPACKED_FLOAT32:e?u.PACKED_2X2_FLOAT16:u.UNPACKED_FLOAT16}(n);if(e===a.DOWNLOAD||e===a.PIXELS)return u.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+e)}function $n(e,t,n){return e[0]+"_"+e[1]+"_"+t+"_"+n}var er=function(e,t){this.variableNames=["A"];for(var n=new Array(e.length),r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;var o=Je(this.rank),i=function(e){var t=e.length;if(t>5)throw Error("Tile for rank "+t+" is not yet supported");if(1===t)return"imod(resRC, "+e[0]+")";for(var n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[],o=0;o<e.length;o++)r.push("imod("+n[o]+", "+e[o]+")");return r.join()}(e);this.userCode="\n      void main() {\n        "+o+" resRC = getOutputCoords();\n        setOutput(getA("+i+"));\n      }\n    "};var tr=function(e,t){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      float unaryOperation(float x) {\n        "+t+"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "},nr="if (isnan(x)) return x;",rr="return abs(x);",or=nr+"\n  return (x < 0.0) ? 0.0 : x;\n",ir=nr+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",ar="return (x >= 0.0) ? x : (exp(x) - 1.0);",ur="\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = "+t.backend_util.SELU_SCALEALPHA+";\n  float scale = "+t.backend_util.SELU_SCALE+";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";var sr="return -x;",lr="return ceil(x);",cr="return floor(x);",dr="return exp(x);",pr="return exp(x) - 1.0;",hr='\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '+t.backend_util.ERF_P+";\n  float a1 = "+t.backend_util.ERF_A1+";\n  float a2 = "+t.backend_util.ERF_A2+";\n  float a3 = "+t.backend_util.ERF_A3+";\n  float a4 = "+t.backend_util.ERF_A4+";\n  float a5 = "+t.backend_util.ERF_A5+";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n",fr="return x;",vr="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",xr="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",gr="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",mr=function(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        "+t+"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "},Cr=function(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;var t=e.length,n=Le("rc",t),r=Je(t),o=function(e,t){if(1===e)return"rc";for(var n="",r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),i=n.slice(-2),a=t<=1?"rc":"vec2("+i.join(",")+")";this.userCode="\n      void main() {\n        "+r+" rc = getOutputCoords();\n        vec4 packedInput = getA("+o+");\n\n        setOutput(getChannel(packedInput, "+a+"));\n      }\n    "},Rr=t.backend_util.segment_util,yr=t.kernel_impls.split,br=t.kernel_impls.tile,wr=t.kernel_impls.topkImpl,Er=t.kernel_impls.whereImpl,Ar={};function Ir(e,t){if(void 0===t&&(t=!1),"linear"===e)return"return x;";if("relu"===e)return t?vr:or;if("elu"===e)return t?gr:ar;if("relu6"===e)return t?xr:ir;if("prelu"===e)return t?pt:ct;throw new Error("Activation "+e+" has not been implemented for the WebGL backend.")}var Tr=function(e){function u(n){var r,o=e.call(this)||this;if(o.pendingRead=new WeakMap,o.pendingDisposal=new WeakSet,o.dataRefCount=new WeakMap,o.numBytesInGPU=0,o.uploadWaitMs=0,o.downloadWaitMs=0,o.warnedAboutMemory=!1,o.warnedAboutCPUBackend=!1,o.pendingDeletes=0,o.disposed=!1,!t.env().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==n){var i=d(t.env().getNumber("WEBGL_VERSION"));o.binaryCache=((r=t.env().getNumber("WEBGL_VERSION"))in Ar||(Ar[r]={}),Ar[r]),o.gpgpu=new mn(i),o.canvas=i.canvas,o.gpgpuCreatedLocally=!0}else o.gpgpu=n,o.binaryCache={},o.gpgpuCreatedLocally=!1,o.canvas=n.gl.canvas;return o.textureManager=new Qn(o.gpgpu),o.numMBBeforeWarning=null==t.env().global.screen?1024:t.env().global.screen.height*t.env().global.screen.width*window.devicePixelRatio*600/1024/1024,o.texData=new t.DataStorage(o,t.engine()),o}return function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}(u,e),u.prototype.numDataIds=function(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes},u.prototype.write=function(e,n,r){if((t.env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||t.env().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===r&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var o={};return this.texData.set(o,{shape:n,dtype:r,values:e,usage:a.UPLOAD,refCount:1}),o},u.prototype.incRef=function(e){this.texData.get(e).refCount++},u.prototype.decRef=function(e){this.texData.has(e)&&this.texData.get(e).refCount--},u.prototype.move=function(e,n,r,o){if(t.env().getBool("DEBUG")&&this.checkNumericalProblems(n),"complex64"===o)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:o,values:n,usage:a.UPLOAD,refCount:1})},u.prototype.disposeIntermediateTensorInfo=function(e){var t=e.dataId;if(this.texData.has(t)){var n=this.texData.get(t);n.refCount--,n.refCount<1&&this.disposeData(t)}},u.prototype.readSync=function(e){var n=this.texData.get(e),r=n.values,o=n.dtype,i=n.complexTensors,a=n.slice,u=n.shape,s=n.isPacked;if(null!=a){var l=void 0;l=s?new mr(u,fr):new tr(u,fr);var c=this.runWebGLProgram(l,[{dataId:e,shape:u,dtype:o}],o),d=this.readSync(c.dataId);return this.disposeIntermediateTensorInfo(c),d}if(null!=r)return this.convertAndCacheOnCPU(e);if("string"===o)return r;var p,h,f=null!=this.activeTimers;if(f&&(p=t.util.now()),"complex64"===o){var v=i.real.dataSync(),x=i.imag.dataSync();h=t.backend_util.mergeRealAndImagArrays(v,x)}else h=this.getValuesFromTexture(e);return f&&(this.downloadWaitMs+=t.util.now()-p),this.convertAndCacheOnCPU(e,h)},u.prototype.read=function(e){return r(this,void 0,void 0,(function(){var n,r,i,a,u,s,l,c,d,p,f,v,x,g,m,C,R,y,b,w,E,A;return o(this,(function(o){switch(o.label){case 0:if(this.pendingRead.has(e))return n=this.pendingRead.get(e),[2,new Promise((function(e){return n.push(e)}))];if(r=this.texData.get(e),i=r.values,a=r.shape,u=r.slice,s=r.dtype,l=r.complexTensors,c=r.isPacked,null!=u)return d=void 0,d=c?new mr(a,fr):new tr(a,fr),p=this.runWebGLProgram(d,[{dataId:e,shape:a,dtype:s}],s),f=this.read(p.dataId),this.disposeIntermediateTensorInfo(p),[2,f];if(null!=i)return[2,this.convertAndCacheOnCPU(e)];if(!t.env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===t.env().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");return v=null,"complex64"!==s&&t.env().get("WEBGL_BUFFER_SUPPORTED")&&(x=this.decode(e),g=this.texData.get(x.dataId),v=(A=this.gpgpu).createBufferFromTexture.apply(A,[g.texture].concat(h(a)))),this.pendingRead.set(e,[]),"complex64"===s?[3,2]:[4,this.gpgpu.createAndWaitForFence()];case 1:o.sent(),o.label=2;case 2:return"complex64"!==s?[3,4]:[4,Promise.all([l.real.data(),l.imag.data()])];case 3:return C=o.sent(),R=C[0],y=C[1],m=t.backend_util.mergeRealAndImagArrays(R,y),[3,5];case 4:null==v?m=this.getValuesFromTexture(e):(b=t.util.sizeFromShape(a),m=this.gpgpu.downloadFloat32MatrixFromBuffer(v,b)),o.label=5;case 5:return null!=x&&this.disposeIntermediateTensorInfo(x),w=this.convertAndCacheOnCPU(e,m),E=this.pendingRead.get(e),this.pendingRead.delete(e),E.forEach((function(e){return e(w)})),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e),this.pendingDeletes--),[2,w]}}))}))},u.prototype.checkNumericalProblems=function(e){if(null!=e)for(var n=0;n<e.length;n++){var r=e[n];if(!g(r)){if(t.env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value "+r+" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value "+r+" cannot be represented on this device.")}}},u.prototype.getValuesFromTexture=function(e){var n,r=this.texData.get(e),o=r.shape,i=r.dtype,a=r.isPacked,u=t.util.sizeFromShape(o);if(t.env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){var s=this.decode(e),l=this.texData.get(s.dataId),c=(n=this.gpgpu).downloadMatrixFromPackedTexture.apply(n,[l.texture].concat(h(o))).subarray(0,u);return this.disposeIntermediateTensorInfo(s),c}var d=t.env().getBool("WEBGL_PACK")&&!0===a,p=d?j(o):o,f=d?new Mt(p):new Vt(p),v=this.runWebGLProgram(f,[{shape:p,dtype:i,dataId:e}],"float32"),x=this.texData.get(v.dataId),g=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(x.texture,x.texShape[0],x.texShape[1]).subarray(0,u);return this.disposeIntermediateTensorInfo(v),g},u.prototype.time=function(e){return r(this,void 0,void 0,(function(){var n,r,i,a,u,s,l;return o(this,(function(o){switch(o.label){case 0:return n=this.activeTimers,r=[],i=!1,null==this.programTimersStack?(this.programTimersStack=r,i=!0):this.activeTimers.push(r),this.activeTimers=r,e(),a=t.util.flatten(this.activeTimers.map((function(e){return e.query}))).filter((function(e){return null!=e})),u=t.util.flatten(this.activeTimers.map((function(e){return e.name}))).filter((function(e){return null!=e})),this.activeTimers=n,i&&(this.programTimersStack=null),s={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?[4,Promise.all(a)]:[3,2];case 1:return l=o.sent(),s.kernelMs=t.util.sum(l),s.getExtraProfileInfo=function(){return l.map((function(e,t){return{name:u[t],ms:e}})).map((function(e){return e.name+": "+e.ms})).join(", ")},[3,3];case 2:s.kernelMs={error:"WebGL query timers are not supported in this environment."},o.label=3;case 3:return this.uploadWaitMs=0,this.downloadWaitMs=0,[2,s]}}))}))},u.prototype.memory=function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}},u.prototype.startTimer=function(){return t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:t.util.now(),endMs:null}},u.prototype.endTimer=function(e){return t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=t.util.now(),e)},u.prototype.getQueryTime=function(e){return r(this,void 0,void 0,(function(){var n;return o(this,(function(r){return t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?[2,this.gpgpu.waitForQueryAndGetTime(e)]:[2,(n=e).endMs-n.startMs]}))}))},u.prototype.disposeData=function(e){if(!this.pendingDisposal.has(e)){if(this.pendingRead.has(e))return this.pendingDisposal.add(e),void this.pendingDeletes++;if(this.texData.has(e)){this.releaseGPUData(e);var t=this.texData.get(e).complexTensors;null!=t&&(t.real.dispose(),t.imag.dispose()),this.texData.delete(e)}}},u.prototype.releaseGPUData=function(e){var t=this.texData.get(e),n=t.texture,r=t.dtype,o=t.texShape,i=t.usage,a=t.isPacked,u=t.slice,s=u&&u.origDataId||e,l=this.dataRefCount.get(s);l>1?this.dataRefCount.set(s,l-1):(this.dataRefCount.delete(s),null!=n&&(this.numBytesInGPU-=this.computeBytes(o,r),this.textureManager.releaseTexture(n,o,i,a)));var c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null},u.prototype.getTexture=function(e){return this.uploadToGPU(e),this.texData.get(e).texture},u.prototype.getDataInfo=function(e){return this.texData.get(e)},u.prototype.getCPUBackend=function(){return t.env().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=t.engine().findBackend("cpu")),this.cpuBackend):null},u.prototype.shouldExecuteOnCPU=function(e,n){var r=this;void 0===n&&(n=128);var o=this.getCPUBackend();return this.warnedAboutCPUBackend||null!=o||(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=o&&e.every((function(e){return null==r.texData.get(e.dataId).texture&&t.util.sizeFromShape(e.shape)<n}))},u.prototype.getGPGPUContext=function(){return this.gpgpu},u.prototype.complex=function(e,n){var r=this.makeOutput(e.shape,"complex64");return this.texData.get(r.dataId).complexTensors={real:t.engine().keep(e.clone()),imag:t.engine().keep(n.clone())},r},u.prototype.real=function(e){return this.texData.get(e.dataId).complexTensors.real.clone()},u.prototype.imag=function(e){return this.texData.get(e.dataId).complexTensors.imag.clone()},u.prototype.slice=function(e,n,r){if(this.shouldExecuteOnCPU([e])){var o=Oe(this.texData.get(e.dataId).values,n,r,e.shape,e.dtype);return this.makeOutput(r,e.dtype,o)}if(0===t.util.sizeFromShape(r))return t.tensor([],r,e.dtype);var i=this.texData.get(e.dataId).isPacked,a=t.slice_util.isSliceContinous(e.shape,n,r);if(i||!a){var u=t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Yn(r):new jn(r),s=u.getCustomSetupFunc(n);return this.compileAndRun(u,[e],null,s)}return this.uploadToGPU(e.dataId),this.shallowSlice(e,n,r)},u.prototype.shallowSlice=function(e,n,r){var o=this.texData.get(e.dataId),i=this.makeOutput(r,e.dtype),a=this.texData.get(i.dataId);Object.assign(a,o),a.shape=r,a.dtype=e.dtype;var u=t.slice_util.computeFlatOffset(n,e.strides);o.slice&&(u+=o.slice.flatOffset),a.slice={flatOffset:u,origDataId:o.slice&&o.slice.origDataId||e.dataId};var s=this.dataRefCount.get(a.slice.origDataId)||1;return this.dataRefCount.set(a.slice.origDataId,s+1),i},u.prototype.stridedSlice=function(e,n,r,o){var i=this,a=this.tryRunOnCpuOrThrow([e],(function(){return i.cpuBackend.stridedSlice(e,n,r,o)}));if(a)return a;var u=t.slice_util.computeOutShape(n,r,o);if(u.some((function(e){return 0===e})))return t.tensor([],u);var s=new qn(n,o,u);return this.compileAndRun(s,[e])},u.prototype.reverse=function(e,n){var r=t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Gn(e.shape,n):new Un(e.shape,n);return this.compileAndRun(r,[e])},u.prototype.concat=function(e,n){if("complex64"===e[0].dtype){var r=e.map((function(e){return t.real(e)})),o=e.map((function(e){return t.imag(e)}));return t.complex(this.concat(r,n),this.concat(o,n))}if(1===e.length)return e[0];if(e.length>t.env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){var i=Math.floor(e.length/2),a=this.concat(e.slice(0,i),n),u=this.concat(e.slice(i),n);return this.concat([a,u],n)}if(t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].rank>1){var s=new mt(e.map((function(e){return e.shape})),n);return this.compileAndRun(s,e)}var l=t.backend_util.computeOutShape(e.map((function(e){return e.shape})),n),c=e.map((function(e){return e.as2D(-1,t.util.sizeFromShape(e.shape.slice(n)))})),d=new gt(c.map((function(e){return e.shape})));return this.compileAndRun(d,c).reshape(l)},u.prototype.neg=function(e){var n=this,r=this.tryRunOnCpuOrThrow([e],(function(){return n.cpuBackend.neg(e)}));if(r)return r;if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,sr,e.dtype);var o=new tr(e.shape,sr);return this.compileAndRun(o,[e])},u.prototype.batchMatMul=function(e,n,r,o){var i=r?e.shape[2]:e.shape[1],a=o?n.shape[1]:n.shape[2],u=r?e.shape[1]:e.shape[2],s=e.shape[0];if((1===i||1===a)&&u>1e3){r&&(e=t.transpose(e,[0,2,1])),o&&(n=t.transpose(n,[0,2,1]));var l=1===a?e:e.as3D(s,u,1),c=1===a?2:1,d=1===a?n.as3D(s,1,u):n;return this.multiply(l,d).sum(c,!0)}var p=t.upcastType(e.dtype,n.dtype),h=new In(e.shape,[s,i,a],r,o);return this.compileAndRun(h,[e,n],p)},u.prototype.fusedBatchMatMul=function(e){var n=e.a,r=e.b,o=e.transposeA,i=e.transposeB,a=e.bias,u=e.activation,s=e.preluActivationWeights,l=o?n.shape[2]:n.shape[1],c=i?r.shape[1]:r.shape[2],d=n.shape[0],p=t.upcastType(n.dtype,r.dtype),h=null!=a,f=null!=s,v=u?Ir(u,!0):null,x=new In(n.shape,[d,l,c],o,i,h,v,f),g=[n,r];return a&&g.push(a),s&&g.push(s),this.compileAndRun(x,g,p)},u.prototype.multiply=function(e,n){if("complex64"===e.dtype){var r=this.texData.get(e.dataId),o=this.texData.get(n.dataId),i=new at(ot,e.shape,n.shape),a=new at(it,e.shape,n.shape),u=[this.makeComplexComponentTensorInfo(e,r.complexTensors.real),this.makeComplexComponentTensorInfo(e,r.complexTensors.imag),this.makeComplexComponentTensorInfo(n,o.complexTensors.real),this.makeComplexComponentTensorInfo(n,o.complexTensors.imag)],s=this.compileAndRun(i,u),l=this.compileAndRun(a,u),c=this.complex(s,l);return s.dispose(),l.dispose(),c}var d=t.upcastType(e.dtype,n.dtype);if(this.shouldExecuteOnCPU([e,n])){r=this.texData.get(e.dataId),o=this.texData.get(n.dataId);var p=Te(e.shape,n.shape,r.values,o.values,d),h=p[0],f=p[1];return this.makeOutput(f,d,h)}if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,lt,e.dtype);var v=new dt(lt,e.shape,n.shape);return this.compileAndRun(v,[e,n],e.dtype)},u.prototype.localResponseNormalization4D=function(e,n,r,o,i){var a=t.env().getBool("WEBGL_PACK_NORMALIZATION")?new wn(e.shape,n,r,o,i):new yn(e.shape,n,r,o,i);return this.compileAndRun(a,[e])},u.prototype.LRNGrad=function(e,t,n,r,o,i,a){var u=new bn(t.shape,r,o,i,a);return this.compileAndRun(u,[t,n,e])},u.prototype.tile=function(e,n){if("string"===e.dtype){var r=this.readSync(e.dataId).map((function(e){return t.util.decodeString(e)})),o=t.buffer(e.shape,e.dtype,r);return br(o,n)}var i=new er(e.shape,n);return this.compileAndRun(i,[e])},u.prototype.pad=function(e,n,r){var o=t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Nn(e.shape,n,r):new Sn(e.shape,n,r);return this.compileAndRun(o,[e])},u.prototype.gather=function(e,t,n){var r=this,o=this.tryRunOnCpuOrThrow([e,t],(function(){return r.cpuBackend.gather(e,t,n)}));if(o)return o;var i=new jt(e.shape,t.size,n);return this.compileAndRun(i,[e,t])},u.prototype.batchToSpaceND=function(e,n,r){t.util.assert(e.rank<=4,(function(){return"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"}));var o=n.reduce((function(e,t){return e*t})),i=t.backend_util.getReshaped(e.shape,n,o),a=t.backend_util.getPermuted(i.length,n.length),u=t.backend_util.getReshapedPermuted(e.shape,n,o),s=t.backend_util.getSliceBeginCoords(r,n.length),l=t.backend_util.getSliceSize(u,r,n.length);return t.transpose(e.reshape(i),a).reshape(u).slice(s,l)},u.prototype.spaceToBatchND=function(e,n,r){t.util.assert(e.rank<=4,(function(){return"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"}));var o=n.reduce((function(e,t){return e*t})),i=[[0,0]];i.push.apply(i,r);for(var a=1+n.length;a<e.shape.length;++a)i.push([0,0]);var u=e.pad(i),s=t.backend_util.getReshaped(u.shape,n,o,!1),l=t.backend_util.getPermuted(s.length,n.length,!1),c=t.backend_util.getReshapedPermuted(u.shape,n,o,!1),d=t.transpose(u.reshape(s),l);return t.reshape(d,c)},u.prototype.reduce=function(e,n,r){var o=e.shape[0],i=e.shape[1],a=t.backend_util.computeOptimalWindowSize(i),u=Math.ceil(i/a),s=new kn({windowSize:a,inSize:i,batchSize:o,outSize:u},n),l=this.compileAndRun(s,[e],r);return 1===l.shape[1]?l:this.reduce(l,n,r)},u.prototype.argReduce=function(e,n,r){void 0===r&&(r=null);var o=e.shape[0],i=e.shape[1];null!=r&&(o=r.shape[0],i=r.shape[1]);var a=t.backend_util.computeOptimalWindowSize(i),u={windowSize:a,inSize:i,batchSize:o,outSize:Math.ceil(i/a)},s=new Be(u,n,null==r),l=[e];null!=r&&l.push(r);var c=this.compileAndRun(s,l,"int32");return 1===c.shape[1]?c:this.argReduce(e,n,c)},u.prototype.argReducePacked=function(e,n,r){void 0===r&&(r=null);var o=null!=r?r.shape:e.shape,i=o[o.length-1],a=t.backend_util.computeOptimalWindowSize(i),u=new tt(o,a,n,null==r),s=null==r?[e]:[e,r],l=this.compileAndRun(u,s,"int32");return l.rank===e.rank?this.argReducePacked(e,n,l):l},u.prototype.sum=function(e,n){t.backend_util.assertAxesAreInnerMostDims("sum",n,e.rank);var r=t.backend_util.computeOutAndReduceShapes(e.shape,n),o=r[0],i=r[1],a=t.util.sizeFromShape(i),u=e.as2D(-1,a),s=t.sumOutType(e.dtype);return this.reduce(u,"sum",s).reshape(o)},u.prototype.prod=function(e,n){var r=this,o=this.tryRunOnCpuOrThrow([e],(function(){return r.cpuBackend.prod(e,n)}));if(o)return o;var i=t.backend_util.computeOutAndReduceShapes(e.shape,n),a=i[0],u=i[1],s=t.util.sizeFromShape(u),l=e.as2D(-1,s),c=t.sumOutType(e.dtype);return this.reduce(l,"prod",c).reshape(a)},u.prototype.unsortedSegmentSum=function(e,n,r){var o=0,i=t.backend_util.getAxesPermutation([o],e.rank),a=e;null!=i&&(a=t.transpose(e,i),o=t.backend_util.getInnerMostAxes(1,e.rank)[0]);var u=Rr.computeOutShape(a.shape,o,r),s=t.util.sizeFromShape([a.shape[o]]),l=a.as2D(-1,s),c=t.sumOutType(e.dtype),d=this.segOpCompute(l,"unsortedSegmentSum",n,c,r).reshape(u);return null!=i&&(d=t.transpose(d,t.backend_util.getUndoAxesPermutation(i))),d},u.prototype.segOpCompute=function(e,n,r,o,i){var a=e.shape[0],u=e.shape[1],s=Rr.segOpComputeOptimalWindowSize(u,i),l=new Xn({windowSize:s,inSize:u,batchSize:a,numSegments:i},n),c=this.compileAndRun(l,[e,r],o);return c.shape[1]===i?c:(r=t.range(0,i).tile([u/s]),this.segOpCompute(c,n,r,o,i))},u.prototype.argMinMaxReduce=function(e,n,r){var o=[n];if(t.backend_util.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),o,e.rank),!t.env().getBool("WEBGL_PACK_REDUCE")||e.rank<=2){var i=t.backend_util.computeOutAndReduceShapes(e.shape,o),a=i[0],u=i[1],s=t.util.sizeFromShape(u),l=e.as2D(-1,s);return this.argReduce(l,r).reshape(a)}return this.argReducePacked(e,r)},u.prototype.argMin=function(e,t){return this.argMinMaxReduce(e,t,"min")},u.prototype.argMax=function(e,t){return this.argMinMaxReduce(e,t,"max")},u.prototype.cumsum=function(e,t,n,r){if(t!==e.rank-1)throw new Error("WebGL cumsum shader expects an inner-most axis="+(e.rank-1)+" but got axis="+t);for(var o=e.shape[t],i=e,a=0;a<=Math.ceil(Math.log2(o))-1;a++){var u=(l=new Nt(e.shape,!1,r)).getCustomSetupFunc(a),s=i;i=this.compileAndRun(l,[i],i.dtype,u),s.dispose()}if(n){var l=new Nt(e.shape,n,r);s=i;i=this.compileAndRun(l,[i]),s.dispose()}return i},u.prototype.equal=function(e,n){if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return vec4(equal(a, b));\n","bool");var r=new dt("return float(a == b);",e.shape,n.shape);return this.compileAndRun(r,[e,n],"bool")},u.prototype.notEqual=function(e,n){if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return vec4(notEqual(a, b));\n","bool");var r=new dt("return float(a != b);",e.shape,n.shape);return this.compileAndRun(r,[e,n],"bool")},u.prototype.less=function(e,n){var r=this,o=this.tryRunOnCpuOrThrow([e,n],(function(){return r.cpuBackend.less(e,n)}));if(o)return o;if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return vec4(lessThan(a, b));\n","bool");var i=new dt("return float(a < b);",e.shape,n.shape);return this.compileAndRun(i,[e,n],"bool")},u.prototype.lessEqual=function(e,n){if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return vec4(lessThanEqual(a, b));\n","bool");var r=new dt("return float(a <= b);",e.shape,n.shape);return this.compileAndRun(r,[e,n],"bool")},u.prototype.greater=function(e,n){var r=this,o=this.tryRunOnCpuOrThrow([e,n],(function(){return r.cpuBackend.greater(e,n)}));if(o)return o;if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return vec4(greaterThan(a, b));\n","bool");var i=new dt("return float(a > b);",e.shape,n.shape);return this.compileAndRun(i,[e,n],"bool")},u.prototype.greaterEqual=function(e,n){if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return vec4(greaterThanEqual(a, b));\n","bool");var r=new dt("return float(a >= b);",e.shape,n.shape);return this.compileAndRun(r,[e,n],"bool")},u.prototype.logicalNot=function(e){var t=new tr(e.shape,"return float(!(x >= 1.0));");return this.compileAndRun(t,[e])},u.prototype.logicalAnd=function(e,n){if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");var r=new dt("return float(a >= 1.0 && b >= 1.0);",e.shape,n.shape);return this.compileAndRun(r,[e,n],"bool")},u.prototype.logicalOr=function(e,n){if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");var r=new dt("return float(a >= 1.0 || b >= 1.0);",e.shape,n.shape);return this.compileAndRun(r,[e,n],"bool")},u.prototype.select=function(e,n,r){var o=new Hn(e.rank,n.shape,n.rank);return this.compileAndRun(o,[e,n,r],t.upcastType(n.dtype,r.dtype))},u.prototype.where=function(e){t.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var n=e.dataSync();return Er(e.shape,n)},u.prototype.topk=function(e,t,n){var r=e.dataSync();return wr(r,e.shape,e.dtype,t,n)},u.prototype.min=function(e,n){t.backend_util.assertAxesAreInnerMostDims("min",n,e.rank);var r=t.backend_util.computeOutAndReduceShapes(e.shape,n),o=r[0],i=r[1],a=t.util.sizeFromShape(i),u=e.as2D(-1,a);return this.reduce(u,"min",u.dtype).reshape(o)},u.prototype.minimum=function(e,n){var r=this,o=this.tryRunOnCpuOrThrow([e,n],(function(){return r.cpuBackend.minimum(e,n)}));if(o)return o;var i=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ht("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,n.shape):new dt("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",e.shape,n.shape);return this.compileAndRun(i,[e,n])},u.prototype.mod=function(e,n){var r=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ht("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,n.shape):new dt("if (b == 0.0) return NAN;\n  return mod(a, b);",e.shape,n.shape);return this.compileAndRun(r,[e,n])},u.prototype.maximum=function(e,n){var r=this,o=this.tryRunOnCpuOrThrow([e,n],(function(){return r.cpuBackend.maximum(e,n)}));if(o)return o;var i=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ht("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,n.shape):new dt("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",e.shape,n.shape);return this.compileAndRun(i,[e,n])},u.prototype.all=function(e,n){t.backend_util.assertAxesAreInnerMostDims("all",n,e.rank);var r=t.backend_util.computeOutAndReduceShapes(e.shape,n),o=r[0],i=r[1],a=t.util.sizeFromShape(i),u=e.as2D(-1,a);return this.reduce(u,"all",u.dtype).reshape(o)},u.prototype.any=function(e,n){t.backend_util.assertAxesAreInnerMostDims("any",n,e.rank);var r=t.backend_util.computeOutAndReduceShapes(e.shape,n),o=r[0],i=r[1],a=t.util.sizeFromShape(i),u=e.as2D(-1,a);return this.reduce(u,"any",u.dtype).reshape(o)},u.prototype.floorDiv=function(e,n){if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n","int32");var r=new dt("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",e.shape,n.shape);return this.compileAndRun(r,[e,n],"int32")},u.prototype.add=function(e,n){if("complex64"===e.dtype&&"complex64"===n.dtype)return this.complexSeparableBinaryOp(e,n,ut);var r=t.upcastType(e.dtype,n.dtype);if(this.shouldExecuteOnCPU([e,n])){var o=this.texData.get(e.dataId),i=this.texData.get(n.dataId),a=Re(e.shape,n.shape,o.values,i.values,r),u=a[0],s=a[1];return this.makeOutput(s,r,u)}if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,ut,r);var l=new dt(ut,e.shape,n.shape);return this.compileAndRun(l,[e,n],r)},u.prototype.packedUnaryOp=function(e,t,n){var r=new mr(e.shape,t);return this.compileAndRun(r,[e],n)},u.prototype.packedBinaryOp=function(e,t,n,r,o){void 0===o&&(o=!1);var i=new ht(n,e.shape,t.shape,o);return this.compileAndRun(i,[e,t],r)},u.prototype.complexSeparableBinaryOp=function(e,n,r){var o=this,i=this.texData.get(e.dataId),a=this.texData.get(n.dataId),u=[[i.complexTensors.real,a.complexTensors.real],[i.complexTensors.imag,a.complexTensors.imag]].map((function(i){var a=i[0],u=i[1],s=o.makeComplexComponentTensorInfo(e,a),l=o.makeComplexComponentTensorInfo(n,u),c=new dt(r,e.shape,n.shape);return o.compileAndRun(c,[s,l],t.upcastType(a.dtype,u.dtype))})),s=u[0],l=u[1],c=this.complex(s,l);return s.dispose(),l.dispose(),c},u.prototype.makeComplexComponentTensorInfo=function(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}},u.prototype.addN=function(e){if(1===e.length)return e[0];if(e.length>t.env().get("WEBGL_MAX_TEXTURES_IN_SHADER")){var n=Math.floor(e.length/2),r=this.addN(e.slice(0,n)),o=this.addN(e.slice(n));return this.addN([r,o])}var i=e.map((function(e){return e.dtype})).reduce((function(e,n){return t.upcastType(e,n)})),a=e.map((function(e){return e.shape})),u=t.env().getBool("WEBGL_PACK")?new ke(e[0].shape,a):new De(e[0].shape,a);return this.compileAndRun(u,e,i)},u.prototype.subtract=function(e,n){if("complex64"===e.dtype&&"complex64"===n.dtype)return this.complexSeparableBinaryOp(e,n,st);var r=t.upcastType(e.dtype,n.dtype);if(this.shouldExecuteOnCPU([e,n])){var o=this.texData.get(e.dataId),i=this.texData.get(n.dataId),a=Se(e.shape,n.shape,o.values,i.values,r),u=a[0],s=a[1];return this.makeOutput(s,r,u)}if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,st,e.dtype);var l=new dt(st,e.shape,n.shape);return this.compileAndRun(l,[e,n],r)},u.prototype.pow=function(e,n){var r=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ht("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,n.shape):new dt("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",e.shape,n.shape),o=t.upcastType(e.dtype,n.dtype);return this.compileAndRun(r,[e,n],o)},u.prototype.ceil=function(e){if(this.shouldExecuteOnCPU([e])){var n=ye(this.texData.get(e.dataId).values,e.dtype);return this.makeOutput(e.shape,e.dtype,n)}if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,lr,e.dtype);var r=new tr(e.shape,lr);return this.compileAndRun(r,[e])},u.prototype.floor=function(e){if(this.shouldExecuteOnCPU([e])){var n=Ee(this.texData.get(e.dataId).values,e.dtype);return this.makeOutput(e.shape,e.dtype,n)}if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,cr,e.dtype);var r=new tr(e.shape,cr);return this.compileAndRun(r,[e])},u.prototype.sign=function(e){var t=new tr(e.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(t,[e])},u.prototype.isNaN=function(e){var t=new tr(e.shape,"return float(isnan(x));");return this.compileAndRun(t,[e],"bool")},u.prototype.isInf=function(e){var t=new tr(e.shape,"return float(isinf(x));");return this.compileAndRun(t,[e],"bool")},u.prototype.isFinite=function(e){var t=new tr(e.shape,"return float(!isnan(x) && !isinf(x));");return this.compileAndRun(t,[e],"bool")},u.prototype.round=function(e){var t=new tr(e.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(t,[e])},u.prototype.exp=function(e){if(this.shouldExecuteOnCPU([e])){var n=be(this.texData.get(e.dataId).values,e.dtype);return this.makeOutput(e.shape,e.dtype,n)}if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,dr,e.dtype);var r=new tr(e.shape,dr);return this.compileAndRun(r,[e])},u.prototype.expm1=function(e){if(this.shouldExecuteOnCPU([e])){var n=we(this.texData.get(e.dataId).values,e.dtype);return this.makeOutput(e.shape,e.dtype,n)}if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,pr,e.dtype);var r=new tr(e.shape,pr);return this.compileAndRun(r,[e])},u.prototype.softmax=function(e,n){var r=t.util.parseAxisParam([n],e.shape),o=t.max(e,r),i=t.backend_util.expandShapeToKeepDim(o.shape,r),a=this.subtract(e,o.reshape(i)),u=this.exp(a),s=this.sum(u,r).reshape(i);return t.div(u,s)},u.prototype.log=function(e){if(this.shouldExecuteOnCPU([e])){var n=Ae(this.texData.get(e.dataId).values,e.dtype);return this.makeOutput(e.shape,e.dtype,n)}if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",e.dtype);var r=new tr(e.shape,"if (x < 0.0) return NAN;\n  return log(x);");return this.compileAndRun(r,[e])},u.prototype.log1p=function(e){var t=new tr(e.shape,"return log(1.0 + x);");return this.compileAndRun(t,[e])},u.prototype.sqrt=function(e){var t=new tr(e.shape,"return sqrt(x);");return this.compileAndRun(t,[e])},u.prototype.rsqrt=function(e){if(this.shouldExecuteOnCPU([e])){var t=_e(this.texData.get(e.dataId).values,e.dtype);return this.makeOutput(e.shape,e.dtype,t)}var n=new tr(e.shape,"return inversesqrt(x);");return this.compileAndRun(n,[e])},u.prototype.reciprocal=function(e){var t=new tr(e.shape,"return 1.0 / x;");return this.compileAndRun(t,[e])},u.prototype.relu=function(e){var n;return n=t.env().getBool("WEBGL_PACK")?new mr(e.shape,vr):new tr(e.shape,or),this.compileAndRun(n,[e])},u.prototype.relu6=function(e){var n;return n=t.env().getBool("WEBGL_PACK")?new mr(e.shape,xr):new tr(e.shape,ir),this.compileAndRun(n,[e])},u.prototype.prelu=function(e,n){var r=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ht(pt,e.shape,n.shape):new dt(ct,e.shape,n.shape);return this.compileAndRun(r,[e,n])},u.prototype.elu=function(e){if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,gr,e.dtype);var n=new tr(e.shape,ar);return this.compileAndRun(n,[e])},u.prototype.eluDer=function(e,n){var r=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ht("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",e.shape,n.shape):new dt("return (b >= 1.0) ? a : a * (b + 1.0);",e.shape,n.shape);return this.compileAndRun(r,[e,n])},u.prototype.selu=function(e){var t=new tr(e.shape,ur);return this.compileAndRun(t,[e])},u.prototype.int=function(e){var t=new tr(e.shape,"return float(int(x));");return this.compileAndRun(t,[e],"int32")},u.prototype.clip=function(e,n,r){var o,i=(o=t.env().getBool("WEBGL_PACK_CLIP")?new vt(e.shape):new ft(e.shape)).getCustomSetupFunc(n,r);return this.compileAndRun(o,[e],null,i)},u.prototype.abs=function(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){var n=Ce(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,n)}if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,rr,e.dtype);var r=new tr(e.shape,rr);return this.compileAndRun(r,[e])},u.prototype.complexAbs=function(e){var t=this.texData.get(e.dataId),n=new xt(e.shape),r=[this.makeComplexComponentTensorInfo(e,t.complexTensors.real),this.makeComplexComponentTensorInfo(e,t.complexTensors.imag)];return this.compileAndRun(n,r)},u.prototype.sigmoid=function(e){var t=new tr(e.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(t,[e])},u.prototype.softplus=function(e){var t=new tr(e.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(t,[e])},u.prototype.asin=function(e){var t=new tr(e.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n");return this.compileAndRun(t,[e])},u.prototype.acos=function(e){var t=new tr(e.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n");return this.compileAndRun(t,[e])},u.prototype.atan=function(e){var t=new tr(e.shape,"if (isnan(x)) return x;\n  return atan(x);\n");return this.compileAndRun(t,[e])},u.prototype.sinh=function(e){var t=new tr(e.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(t,[e])},u.prototype.cosh=function(e){var t=new tr(e.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(t,[e])},u.prototype.tanh=function(e){var t=new tr(e.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(t,[e])},u.prototype.asinh=function(e){var t=new tr(e.shape,"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));");return this.compileAndRun(t,[e])},u.prototype.acosh=function(e){var t=new tr(e.shape,"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));");return this.compileAndRun(t,[e])},u.prototype.atanh=function(e){var t=new tr(e.shape,"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;");return this.compileAndRun(t,[e])},u.prototype.erf=function(e){var t=new tr(e.shape,hr);return this.compileAndRun(t,[e])},u.prototype.step=function(e,t){var n=new tr(e.shape,function(e){return void 0===e&&(e=0),nr+"\n    return x > 0.0 ? 1.0 : float("+e+");\n  "}(t));return this.compileAndRun(n,[e])},u.prototype.conv2dByMatMul=function(e,n,r,o,i,a){var u=e.shape,s=this.texData.get(e.dataId),l=r.inChannels,c=u[0]*u[1]*u[2],d=r.outChannels,p="channelsLast"===r.dataFormat,h=(1===c||1===d)&&l>1e3,f=u[2]%2!=0&&!!s.isPacked;if(h||!t.env().getBool("WEBGL_LAZILY_UNPACK")||!t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!f){var v=p?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],x=t.reshape(e,[1,v,r.inChannels]),g=t.reshape(n,[1,r.inChannels,r.outChannels]),m=this.fusedBatchMatMul({a:x,b:g,transposeA:!1,transposeB:!1,bias:o,activation:i,preluActivationWeights:a});return t.reshape(m,r.outShape)}var C=p?u[0]*u[1]*(u[2]+1):u[0]*u[2]*(u[3]+1),R={dataId:e.dataId,shape:[1,C,r.inChannels],dtype:e.dtype},y=s.shape;s.shape=s.shape.slice(),s.shape[s.shape.length-2]++,t.util.assert(q(s.shape,R.shape),(function(){return"packed reshape "+s.shape+" to "+R.shape+" isn't free"}));var b=t.reshape(n,[1,r.inChannels,r.outChannels]),w=this.fusedBatchMatMul({a:R,b:b,transposeA:!1,transposeB:!1,bias:o,activation:i,preluActivationWeights:a}),E=this.texData.get(w.dataId);return t.util.assert(E.isPacked,(function(){return"batchMatMul result is expected to be packed"})),s.shape=y,E.shape=r.outShape,t.engine().makeTensorFromDataId(w.dataId,r.outShape,w.dtype)},u.prototype.conv2dWithIm2Row=function(e,t,n,r,o,i){var a=n.filterWidth,u=n.filterHeight,s=n.inChannels,l=n.outWidth,c=n.outHeight,d="channelsLast"===n.dataFormat,p=a*u*s,h=c*l,f=[p,h],v=e.squeeze([0]),x=t.reshape([1,p,-1]),g=new Rn(f,v.shape,n),m=this.compileAndRun(g,[v]).reshape([1,f[0],f[1]]),C=null!=r,R=null!=i,y=o?Ir(o,!0):null,b=new In(m.shape,[1,h,n.outChannels],!0,!1,C,y,R),w=[m,x];r&&w.push(r),R&&w.push(i);var E=this.compileAndRun(b,w);return d?E.reshape([1,c,l,n.outChannels]):E.reshape([1,n.outChannels,c,l])},u.prototype.fusedConv2d=function(e){var n=e.input,r=e.filter,o=e.convInfo,i=e.bias,a=e.activation,u=e.preluActivationWeights;if(1===o.filterHeight&&1===o.filterWidth&&1===o.dilationHeight&&1===o.dilationWidth&&1===o.strideHeight&&1===o.strideWidth&&("SAME"===o.padInfo.type||"VALID"===o.padInfo.type))return this.conv2dByMatMul(n,r,o,i,a,u);if(t.env().getBool("WEBGL_CONV_IM2COL")&&1===n.shape[0])return this.conv2dWithIm2Row(n,r,o,i,a,u);var s=null!=i,l=null!=u,c=a?Ir(a,!1):null,d=new It(o,s,c,l),p=[n,r];return i&&p.push(i),u&&p.push(u),this.compileAndRun(d,p)},u.prototype.conv2d=function(e,n,r){if(1===r.filterHeight&&1===r.filterWidth&&1===r.dilationHeight&&1===r.dilationWidth&&1===r.strideHeight&&1===r.strideWidth&&("SAME"===r.padInfo.type||"VALID"===r.padInfo.type))return this.conv2dByMatMul(e,n,r);if(t.env().getBool("WEBGL_CONV_IM2COL")&&1===e.shape[0])return this.conv2dWithIm2Row(e,n,r);var o=new It(r);return this.compileAndRun(o,[e,n])},u.prototype.conv2dDerInput=function(e,t,n){var r=new yt(n);return this.compileAndRun(r,[e,t])},u.prototype.conv2dDerFilter=function(e,t,n){var r=new Rt(n);return this.compileAndRun(r,[e,t])},u.prototype.fusedDepthwiseConv2D=function(e){var n,r=e.input,o=e.filter,i=e.convInfo,a=e.bias,u=e.activation,s=e.preluActivationWeights,l=t.env().getBool("WEBGL_PACK_DEPTHWISECONV")&&i.strideWidth<=2&&i.outChannels/i.inChannels==1,c=u?Ir(u,l):null,d=[r,o],p=null!=a,h=null!=s;return p&&d.push(a),h&&d.push(s),l?(n=new Ot(i,p,c,h),this.compileAndRun(n,d)):(n=new _t(i,p,c,h),this.compileAndRun(n,d))},u.prototype.depthwiseConv2D=function(e,n,r){var o;return t.env().getBool("WEBGL_PACK_DEPTHWISECONV")&&r.strideWidth<=2&&r.outChannels/r.inChannels==1?(o=new Ot(r),this.compileAndRun(o,[e,n])):(o=new _t(r),this.compileAndRun(o,[e,n]))},u.prototype.depthwiseConv2DDerInput=function(e,t,n){var r=new At(n);return this.compileAndRun(r,[e,t])},u.prototype.depthwiseConv2DDerFilter=function(e,t,n){var r=new Et(n);return this.compileAndRun(r,[e,t])},u.prototype.conv3d=function(e,t,n){var r=new Tt(n);return this.compileAndRun(r,[e,t])},u.prototype.conv3dDerInput=function(e,t,n){var r=new wt(n);return this.compileAndRun(r,[e,t])},u.prototype.conv3dDerFilter=function(e,t,n){var r=new bt(n);return this.compileAndRun(r,[e,t])},u.prototype.cast=function(e,n){return t.backend_util.castTensor(e,n,this)},u.prototype.unstack=function(e,t){for(var n=e.shape[t],r=new Array(e.rank-1),o=0,i=0;i<e.rank;i++)i!==t&&(r[o++]=e.shape[i]);var a=new Array(e.rank).fill(0),u=e.shape.slice();u[t]=1;var s=new Array(n);for(i=0;i<s.length;i++)a[t]=i,s[i]=this.slice(e,a,u).reshape(r);return s},u.prototype.avgPool3d=function(e,t){var n=new Dn(t,"avg",!1);return this.compileAndRun(n,[e],"float32")},u.prototype.avgPool3dBackprop=function(e,t,n){var r=new rt(n);return this.compileAndRun(r,[e],t.dtype)},u.prototype.maxPool3d=function(e,t){var n=new Dn(t,"max",!1);return this.compileAndRun(n,[e],"float32")},u.prototype.maxPool3dBackprop=function(e,t,n,r){var o=new Dn(r,"max",!0),i=this.compileAndRun(o,[t]),a=new An(r),u=this.compileAndRun(a,[e,i],t.dtype);return i.dispose(),u},u.prototype.resizeBilinear=function(e,n,r,o){var i=t.env().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Vn(e.shape,n,r,o):new Ln(e.shape,n,r,o);return this.compileAndRun(i,[e],"float32")},u.prototype.resizeBilinearBackprop=function(e,t,n){var r=new Pn(e,t,n);return this.compileAndRun(r,[e])},u.prototype.resizeNearestNeighbor=function(e,t,n,r){var o=new Wn(e.shape,t,n,r);return this.compileAndRun(o,[e])},u.prototype.resizeNearestNeighborBackprop=function(e,t,n){var r=new Mn(e,t,n);return this.compileAndRun(r,[e])},u.prototype.multinomial=function(e,n,r,o){var i=n?e:t.softmax(e),a=i.shape[0],u=i.shape[1],s=new Tn(a,u,r),l=s.getCustomSetupFunc(o);return this.compileAndRun(s,[i],"int32",l)},u.prototype.oneHot=function(e,t,n,r){var o=new _n(e.size,t,n,r);return this.compileAndRun(o,[e])},u.prototype.diag=function(e){var t=new Lt(e.size);return this.compileAndRun(t,[e])},u.prototype.cropAndResize=function(e,t,n,r,o,i){var a=new St(e.shape,t.shape,r,o,i);return this.compileAndRun(a,[e,t,n],"float32")},u.prototype.depthToSpace=function(e,n,r){t.util.assert(n>1,(function(){return"blockSize should be > 1 for depthToSpace, but was: "+n}));var o=e.shape[0],i="NHWC"===r?e.shape[1]:e.shape[2],a="NHWC"===r?e.shape[2]:e.shape[3],u="NHWC"===r?e.shape[3]:e.shape[1],s=i*n,l=a*n,c=u/(n*n),d=new Pt("NHWC"===r?[o,s,l,c]:[o,c,s,l],n,r);return this.compileAndRun(d,[e])},u.prototype.split=function(e,t,n){return yr(e,t,n)},u.prototype.scatterND=function(e,n,r){var o=t.backend_util.calculateShapes(n,e,r),i=o.sliceRank,a=o.numUpdates,u=o.sliceSize,s=o.strides,l=o.outputSize,c=[l/u,u],d=e.reshape([a,i]),p=n.reshape([a,u]);if(0===l)return t.backend_util.reshapeTensor(t.tensor([]),r);var h=t.scalar(0),f=new zn(a,i,d.rank,p.rank,s,c);return this.compileAndRun(f,[p,d,h]).reshape(r)},u.prototype.sparseToDense=function(e,n,r,o){var i=t.backend_util.calculateShapes(n,e,r),a=i.sliceRank,u=i.numUpdates,s=i.strides,l=i.outputSize,c=new zn(u,a,e.rank,n.rank,s,[l,1],!1);return this.compileAndRun(c,[n,e,o]).reshape(r)},u.prototype.fft=function(e){return this.fftImpl(e,!1)},u.prototype.ifft=function(e){return this.fftImpl(e,!0)},u.prototype.fftImpl=function(e,t){var n=this.texData.get(e.dataId),r=new Xt(Gt,e.shape,t),o=new Xt(zt,e.shape,t),i=[this.makeComplexComponentTensorInfo(e,n.complexTensors.real),this.makeComplexComponentTensorInfo(e,n.complexTensors.imag)],a=this.compileAndRun(r,i),u=this.compileAndRun(o,i),s=this.complex(a,u).as2D(e.shape[0],e.shape[1]);return a.dispose(),u.dispose(),s},u.prototype.gatherND=function(e,n){var r=n.shape,o=r[r.length-1],i=t.backend_util.prepareAndValidate(e,n),a=i[0],u=i[1],s=i[2],l=i[3],c=n.reshape([u,o]),d=e.reshape([e.size/s,s]),p=new Kt(o,l,[u,s]);return this.compileAndRun(p,[d,c]).reshape(a)},u.prototype.fill=function(e,n,r){if("string"===(r=r||t.util.inferDtype(n))){var o=t.util.getArrayFromDType(r,t.util.sizeFromShape(e));return o.fill(n),t.engine().makeTensor(o,e,r,this)}var i=new Ht(e,n),a=i.getCustomSetupFunc(n);return this.compileAndRun(i,[],r,a)},u.prototype.onesLike=function(e){if("string"===e.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(e.shape,1,e.dtype)},u.prototype.zerosLike=function(e){return this.fill(e.shape,"string"===e.dtype?"":0,e.dtype)},u.prototype.linspace=function(e,n,r){return t.backend_util.linspaceImpl(e,n,r)},u.prototype.makeTensorInfo=function(e,t,n){var r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}},u.prototype.makeOutput=function(e,n,r){var o=this.makeTensorInfo(e,n,r).dataId;return t.engine().makeTensorFromDataId(o,e,n,this)},u.prototype.unpackTensor=function(e){var t=new Cr(e.shape);return this.runWebGLProgram(t,[e],e.dtype)},u.prototype.packTensor=function(e){var t=new On(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)},u.prototype.packedReshape=function(e,t){var n=[X(e.shape)].concat(H(e.shape)),r={dtype:e.dtype,shape:n,dataId:e.dataId},o=[X(t)].concat(H(t)),i=new Bn(o,n),a=this.runWebGLProgram(i,[r],e.dtype,null,!0);return{dataId:a.dataId,shape:t,dtype:a.dtype}},u.prototype.decode=function(e){var t,n=this.texData.get(e),r=n.isPacked,o=n.shape,i=n.dtype,a=j(o);t=r?new Bt(a):new kt(a);return{dtype:i,shape:o,dataId:this.runWebGLProgram(t,[{shape:a,dtype:i,dataId:e}],i,null,!0).dataId}},u.prototype.runWebGLProgram=function(e,n,r,o,a){var u=this;void 0===a&&(a=!1);var s=this.makeTensorInfo(e.outputShape,r),l=this.texData.get(s.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===i.DENSE){var c=h(e.outputShape);l.texShape=c.map((function(e){return 2*e}))}if(null!=e.outTexUsage&&(l.usage=e.outTexUsage),0===t.util.sizeFromShape(s.shape))return l.values=t.util.getTypedArrayFromDType(s.dtype,0),s;var d=[],p=n.map((function(n){if("complex64"===n.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var r=u.texData.get(n.dataId);if(null==r.texture){if(!e.packedInputs&&t.util.sizeFromShape(n.shape)<=t.env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:n.shape,texData:null,isUniform:!0,uniformValues:r.values};e.packedInputs&&(r.isPacked=!0,r.shape=n.shape)}else if(!!r.isPacked!=!!e.packedInputs)n=r.isPacked?u.unpackTensor(n):u.packTensor(n),d.push(n),r=u.texData.get(n.dataId);else if(r.isPacked&&!q(r.shape,n.shape)){var o=n,i=n.shape;n.shape=r.shape,n=u.packedReshape(n,i),d.push(n),r=u.texData.get(n.dataId),o.shape=i}return u.uploadToGPU(n.dataId),{shape:n.shape,texData:r,isUniform:!1}}));this.uploadToGPU(s.dataId);var f,v={shape:s.shape,texData:l,isUniform:!1},x=function(e,t,n){var r="";t.concat(n).forEach((function(e){var t=null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0,n=e.isUniform?"uniform":e.texData.texShape;r+=e.shape+"_"+n+"_"+t}));var o=e.userCode,i=e.constructor.name;return i+="_"+r+"_"+o}(e,p,v),g=this.getAndSaveBinary(x,(function(){return function(e,n,r,o){var i=n.userCode,a=r.map((function(e,t){var r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:n.variableNames[t],shapeInfo:r}})),u=a.map((function(e){return e.shapeInfo})),s={logicalShape:o.shape,texShape:o.texData.texShape,isUniform:!1,isPacked:o.texData.isPacked,flatOffset:null},l=ze(a,s,i,n.packedInputs),c=e.createProgram(l),d=null,p=e.getUniformLocation(c,"NAN",!1);1===t.env().getNumber("WEBGL_VERSION")&&(d=e.getUniformLocation(c,"INFINITY",!1));for(var h={},f=0;f<n.variableNames.length;f++){var v=n.variableNames[f];h[v]=e.getUniformLocation(c,v,!1),h["offset"+v]=e.getUniformLocation(c,"offset"+v,!1)}return{program:n,source:l,webGLProgram:c,uniformLocations:h,inShapeInfos:u,outShapeInfo:s,infLoc:d,nanLoc:p}}(u.gpgpu,e,p,v)})),m=null!=this.activeTimers;if(m&&(f=this.startTimer()),function(e,n,r,o,i){Cn(n.inShapeInfos,r),Cn([n.outShapeInfo],[o]);var a=o.texData.texture,u=o.texData.texShape;o.texData.isPacked?e.setOutputPackedMatrixTexture(a,u[0],u[1]):e.setOutputMatrixTexture(a,u[0],u[1]),e.setProgram(n.webGLProgram),1===t.env().getNumber("WEBGL_VERSION")&&null!==n.infLoc&&e.gl.uniform1f(n.infLoc,1/0),null!==n.nanLoc&&e.gl.uniform1f(n.nanLoc,NaN),r.forEach((function(r,o){var i=n.program.variableNames[o],a=n.uniformLocations[i],u=n.uniformLocations["offset"+i];if(null!=a)if(r.isUniform)if(t.util.sizeFromShape(r.shape)<2)e.gl.uniform1f(a,r.uniformValues[0]);else{var s=r.uniformValues;s instanceof Float32Array||(s=new Float32Array(s)),e.gl.uniform1fv(a,s)}else null!=r.texData.slice&&null!=u&&e.gl.uniform1i(u,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture,a,o)})),null!=i&&i(e,n.webGLProgram),e.executeProgram()}(this.gpgpu,g,p,v,o),d.forEach((function(e){return u.disposeIntermediateTensorInfo(e)})),m&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)})),!t.env().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&!1===a){var C=this.unpackTensor(s);return this.disposeIntermediateTensorInfo(s),C}return s},u.prototype.compileAndRun=function(e,n,r,o,i){void 0===i&&(i=!1),r=r||n[0].dtype;var a=this.runWebGLProgram(e,n,r,o,i);return t.engine().makeTensorFromDataId(a.dataId,a.shape,a.dtype)},u.prototype.getAndSaveBinary=function(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]},u.prototype.getTextureManager=function(){return this.textureManager},u.prototype.dispose=function(){var e=this;if(!this.disposed){if(!t.env().getBool("IS_TEST"))Object.keys(this.binaryCache).forEach((function(t){e.gpgpu.deleteProgram(e.binaryCache[t].webGLProgram),delete e.binaryCache[t]}));this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}},u.prototype.floatPrecision=function(){var e=this;return null==this.floatPrecisionValue&&(this.floatPrecisionValue=t.tidy((function(){if(!t.env().get("WEBGL_RENDER_FLOAT32_ENABLED")){var n=t.env().getBool("DEBUG");t.env().set("DEBUG",!1);var r=e.abs(t.scalar(1e-8)).dataSync()[0];if(t.env().set("DEBUG",n),r>0)return 32}return 16}))),this.floatPrecisionValue},u.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},u.prototype.uploadToGPU=function(e){var n,r=this.texData.get(e),o=r.shape,i=r.dtype,u=r.values,s=r.texture,l=r.usage,c=r.isPacked;if(null==s){var d,p=null!=this.activeTimers;p&&(d=t.util.now());var h=r.texShape;if(null==h&&(h=K(o,c),r.texShape=h),null!=u){var v=j(o),x=void 0,g=h[1],m=h[0],C=u instanceof Uint8Array;c?(g=(n=f(h[0],h[1]))[0],m=n[1],x=new Ut(v,[m,g],C)):x=new Wt(v,[m,g],C);var R=this.makeTensorInfo([m,g],i);this.texData.get(R.dataId).usage=C?a.PIXELS:a.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(R.dataId),g,m,u);var y=this.runWebGLProgram(x,[R],i,null,!0),b=this.texData.get(y.dataId);r.texture=b.texture,r.texShape=b.texShape,r.isPacked=b.isPacked,r.usage=b.usage,this.disposeIntermediateTensorInfo(R),this.texData.delete(y.dataId),r.values=null,p&&(this.uploadWaitMs+=t.util.now()-d)}else{var w=this.acquireTexture(h,l,i,c);r.texture=w}}},u.prototype.convertAndCacheOnCPU=function(e,t){var n=this.texData.get(e),r=n.dtype;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){for(var n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length),r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}throw new Error("Unknown dtype "+t)}(t,r)),n.values},u.prototype.acquireTexture=function(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){var o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+o+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,r)},u.prototype.computeBytes=function(e,n){return e[0]*e[1]*t.util.bytesPerElement(n)},u.prototype.tryRunOnCpuOrThrow=function(e,n){if(this.shouldExecuteOnCPU(e))try{return n()}catch(e){if(t.env().getBool("IS_TEST"))throw new Error("CPU forwarding failed")}return null},u}(t.KernelBackend);function _r(){t.env().set("WEBGL_FORCE_F16_TEXTURES",!0)}t.device_util.isBrowser()&&t.registerBackend("webgl",(function(){return new Tr}),2);var Or={forceHalfFloat:_r};function Sr(e){return function(t){var n=t.inputs,r=t.backend,o=n.x,i=r,a=new tr(o.shape,e);return i.runWebGLProgram(a,[o],o.dtype)}}function Nr(e,n,r,o){return function(i){var a=i.inputs,u=i.backend,s=a,l=s.a,c=s.b,d=u,p=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ht(n,l.shape,c.shape,!!r):new dt(e,l.shape,c.shape),h=o||l.dtype;return d.runWebGLProgram(p,[l,c],h)}}var Fr=Nr("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n","\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"),Dr={kernelName:t.Atan2,backendName:"webgl",kernelFunc:Fr};function kr(e){var t=e.inputs,n=e.backend,r=t.x;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var Br={kernelName:t.Identity,backendName:"webgl",kernelFunc:kr};var Pr={kernelName:t.AvgPool,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,r=e.backend,o=e.attrs,i=n.x;ie(i,"avgPool");var a=o.filterSize,u=o.strides,s=o.pad,l=o.dimRoundingMode;t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(u,1),(function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+u+" and dilations '1'"}));var c=t.backend_util.computePool2DInfo(i.shape,a,u,1,s,l);if(1===c.filterWidth&&1===c.filterHeight&&t.util.arraysEqual(c.inShape,c.outShape))return kr({inputs:{x:i},backend:r});var d=new Fn(c,"avg",!1);return r.runWebGLProgram(d,[i],"float32")}};var Lr,Vr={kernelName:t.AvgPoolBackprop,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,r=e.backend,o=e.attrs,i=n.dy,a=n.input,u=a;ie([i,a],"avgPoolBackprop");var s=o.filterSize,l=o.strides,c=o.pad,d=t.backend_util.computePool2DInfo(u.shape,s,l,1,c),p=new nt(d);return r.runWebGLProgram(p,[i],u.dtype)}},Mr=function(e,n,r,o,i,a){this.outputShape=[],this.variableNames=["x","mean","variance"],t.backend_util.assertAndGetBroadcastShape(e,n),t.backend_util.assertAndGetBroadcastShape(e,r);var u="0.0";null!=o&&(t.backend_util.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),u="getOffsetAtOutCoords()");var s="1.0";null!=i&&(t.backend_util.assertAndGetBroadcastShape(e,i),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = "+u+";\n        float scale = "+s+";\n        float inv = scale * inversesqrt(variance + float("+a+"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "},Wr=function(e,n,r,o,i,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],t.backend_util.assertAndGetBroadcastShape(e,n),t.backend_util.assertAndGetBroadcastShape(e,r);var u="vec4(0.0)";null!=o&&(t.backend_util.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),u="getOffsetAtOutCoords()");var s="vec4(1.0)";null!=i&&(t.backend_util.assertAndGetBroadcastShape(e,i),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = "+u+";\n        vec4 scale = "+s+";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4("+a+"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "},Ur={kernelName:t.FusedBatchNorm,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,r=e.backend,o=e.attrs,i=n.x,a=n.mean,u=n.variance,s=n.offset,l=n.scale;t.util.assert(a.shape.length===u.shape.length,(function(){return"Batch normalization gradient requires mean and variance to have equal ranks."})),t.util.assert(null==s||a.shape.length===s.shape.length,(function(){return"Batch normalization gradient requires mean and offset to have equal ranks."})),t.util.assert(null==l||a.shape.length===l.shape.length,(function(){return"Batch normalization gradient requires mean and scale to have equal ranks."}));var c=o.varianceEpsilon;null==c&&(c=.001);var d=[i,a,u],p=null;null!=s&&(p=s.shape,d.push(s));var h=null;null!=l&&(h=l.shape,d.push(l));var f=t.env().getBool("WEBGL_PACK_NORMALIZATION")?new Wr(i.shape,a.shape,u.shape,p,h,c):new Mr(i.shape,a.shape,u.shape,p,h,c);return r.runWebGLProgram(f,d,d[0].dtype)}},Gr=Sr("if (isnan(x)) return x;\n  return cos(x);\n"),zr={kernelName:t.Cos,backendName:"webgl",kernelFunc:Gr},Xr=Nr("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;","\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",!0),Hr={kernelName:t.Div,backendName:"webgl",kernelFunc:Xr},jr=function(e){this.variableNames=["Image"],this.outputShape=[];var t=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = "+t+" - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < "+t+") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    "},Kr={kernelName:t.FlipLeftRight,backendName:"webgl",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.image,o=n,i=new jr(r.shape);return o.runWebGLProgram(i,[r],r.dtype)}},Yr=function(e){this.variableNames=["A"];var t=Ve(),n=e[0],r=e[1];this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+r+".0, "+n+".0);\n\n        vec4 values = "+t.texture2D+"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "},qr=function(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var t=Ve(),n=e[0],r=e[1];this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2("+r+".0, "+n+".0);\n            vec4 values = "+t.texture2D+"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        "+t.output+" = result;\n      }\n    "},Qr={kernelName:t.FromPixels,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,r=e.backend,o=e.attrs,i=n.pixels,u=o.numChannels,s="undefined"!=typeof HTMLVideoElement&&i instanceof HTMLVideoElement,l="undefined"!=typeof HTMLImageElement&&i instanceof HTMLImageElement,c=s?[i.videoWidth,i.videoHeight]:[i.width,i.height],d=c[0],p=c[1],h=[p,d],f=[p,d,u];(l||s)&&(null==Lr&&(Lr=document.createElement("canvas").getContext("2d")),Lr.canvas.width=d,Lr.canvas.height=p,Lr.drawImage(i,0,0,d,p),i=Lr.canvas);var v=r.makeTensorInfo(h,"int32");r.texData.get(v.dataId).usage=a.PIXELS,r.gpgpu.uploadPixelDataToTexture(r.getTexture(v.dataId),i);var x=t.env().getBool("WEBGL_PACK")?new qr(f):new Yr(f),g=r.runWebGLProgram(x,[v],"int32");return r.disposeData(v.dataId),g}};function Zr(e,n,r,o){for(var i=function(e){for(var n=[];0===n.length||1!==n[n.length-1].outSize;){var r=n.length?n[n.length-1].outSize:e[1],o=t.backend_util.computeOptimalWindowSize(r);n.push({inSize:r,windowSize:o,outSize:Math.ceil(r/o)})}return n}(e.shape),a=e,u=0;u<i.length;u++){var s=i[u],l=s.inSize,c=s.windowSize,d=s.outSize,p=new kn({windowSize:c,inSize:l,batchSize:e.shape[0],outSize:d},r),h=a;a=o.runWebGLProgram(p,[a],n),h.dataId!==e.dataId&&o.disposeData(h.dataId)}return a}function Jr(e){var n=e.inputs,r=e.backend,o=e.attrs,i=n.x,a=o.shape,u=r,s=t.util.sizeFromShape(i.shape),l=t.util.inferFromImplicitShape(a,s),c=t.util.sizeFromShape(l);t.util.assert(s===c,(function(){return"The new shape ("+l+") has "+c+" elements and the old shape ("+i.shape+") has "+s+" elements. The new shape and old shape must have the same number of elements."}));var d=u.texData.get(i.dataId);return!d.isPacked||q(i.shape,l)||null!==d.texture&&q(d.shape,l)?(u.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype}):function(e,t,n){var r=[X(e.shape)].concat(H(e.shape)),o={dtype:e.dtype,shape:r,dataId:e.dataId},i=[X(t)].concat(H(t)),a=new Bn(i,r),u=n.runWebGLProgram(a,[o],e.dtype,null,!0);return{dataId:u.dataId,shape:t,dtype:u.dtype}}(i,l,u)}var $r={kernelName:t.Reshape,backendName:"webgl",kernelFunc:Jr};var eo=function(e,t){this.variableNames=["A"];for(var n=new Array(e.length),r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;var o=Je(this.rank),i=function(e){var t=e.length;if(t>6)throw Error("Transpose for rank "+t+" is not yet supported");for(var n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t),o=0;o<e.length;o++)r[e[o]]=n[o];return r.join()}(t);this.userCode="\n    void main() {\n      "+o+" resRC = getOutputCoords();\n      setOutput(getA("+i+"));\n    }\n    "};var to=function(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;for(var n=new Array(e.length),r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");var o=Je(this.rank),i=Pe("rc",this.rank),a=new Array(this.rank);for(r=0;r<t.length;r++)a[t[r]]=i[r];var u="vec2("+a.slice(-2).join()+")",s="++"+i[this.rank-1]+" < "+n[this.rank-1],l="getChannel(getA("+a.join()+"), "+u+")";this.userCode="\n    void main() {\n      "+o+" rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = "+l+";\n      if("+s+") {\n        result[1] = "+l+";\n      }\n      --"+i[this.rank-1]+";\n      if(++"+i[this.rank-2]+" < "+n[this.rank-2]+") {\n        result[2] = "+l+";\n        if("+s+") {\n          result[3] = "+l+";\n        }\n      }\n      setOutput(result);\n    }\n    "};function no(e,n,r){var o=t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new to(e.shape,n):new eo(e.shape,n);return r.runWebGLProgram(o,[e],e.dtype)}var ro={kernelName:t.Max,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,r=e.attrs,o=e.backend,i=n.x,a=r,u=a.reductionIndices,s=a.keepDims,l=o,c=i.shape.length,d=t.util.parseAxisParam(u,i.shape),p=d,h=t.backend_util.getAxesPermutation(p,c),f=null!=h,v=l.shouldExecuteOnCPU([i]),x=i;if(f){if(v){for(var g=l.texData.get(x.dataId).values,m=new Array(c),C=0;C<m.length;C++)m[C]=i.shape[h[C]];var R=Ne(g,i.shape,i.dtype,h,m);x=l.makeTensorInfo(m,i.dtype),l.texData.get(x.dataId).values=R}else x=no(i,h,l);p=t.backend_util.getInnerMostAxes(p.length,c)}t.backend_util.assertAxesAreInnerMostDims("max",p,c);var y,b=t.backend_util.computeOutAndReduceShapes(x.shape,p),w=b[0],E=b[1],A=w;if(s&&(A=t.backend_util.expandShapeToKeepDim(w,d)),v){g=l.texData.get(x.dataId).values;var I=Ie(g,t.util.sizeFromShape(E),A,i.dtype);y=l.makeTensorInfo(A,i.dtype),l.texData.get(y.dataId).values=I}else y=function(e,n,r,o){var i=t.util.sizeFromShape(n),a=Jr({inputs:{x:e},attrs:{shape:[t.util.sizeFromShape(e.shape)/i,i]},backend:o}),u=Zr(a,e.dtype,"max",o),s=Jr({inputs:{x:u},attrs:{shape:r},backend:o});return o.disposeIntermediateTensorInfo(a),o.disposeIntermediateTensorInfo(u),s}(x,E,A,l);return f&&l.disposeIntermediateTensorInfo(x),y}};var oo={kernelName:t.MaxPool,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,r=e.backend,o=e.attrs,i=n.x;ie(i,"maxPool");var a=o.filterSize,u=o.strides,s=o.pad,l=o.dimRoundingMode;t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(u,1),(function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+u+" and dilations '1'"}));var c=t.backend_util.computePool2DInfo(i.shape,a,u,1,s,l);if(1===c.filterWidth&&1===c.filterHeight&&t.util.arraysEqual(c.inShape,c.outShape))return kr({inputs:{x:i},backend:r});var d=new Fn(c,"max",!1);return r.runWebGLProgram(d,[i],i.dtype)}};var io={kernelName:t.MaxPoolBackprop,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,r=e.backend,o=e.attrs,i=n.dy,a=n.input,u=a;ie([a,n.output],"maxPoolBackprop");var s=o.filterSize,l=o.strides,c=o.pad,d=o.dimRoundingMode,p=t.backend_util.computePool2DInfo(u.shape,s,l,1,c,d),h=new Fn(p,"max",!0),f=r.runWebGLProgram(h,[u],u.dtype),v=new En(p),x=r.runWebGLProgram(v,[i,f],u.dtype);return r.disposeIntermediateTensorInfo(f),x}};var ao={kernelName:t.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,r=e.attrs,o=e.backend,i=n.x,a=r,u=a.filterSize,s=a.strides,l=a.pad,c=a.includeBatchInIndex,d=o;t.util.assert(4===i.shape.length,(function(){return"Error in maxPool: input must be rank 4 but got rank "+i.shape.length+"."}));var p=[1,1];t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(s,p),(function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+s+" and dilations '"+p+"'"}));var h=t.backend_util.computePool2DInfo(i.shape,u,s,p,l),f=function(e,t,n,r){var o=new Fn(n,"max",!1),i=r.runWebGLProgram(o,[e],"float32");return o=new Fn(n,"max",!0,!0,t),[i,r.runWebGLProgram(o,[e],"float32")]}(i,c,h,d);return[f[0],f[1]]}},uo={kernelName:t.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,r=e.backend,o=e.attrs;t.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var i=n,a=i.boxes,u=i.scores,s=o,l=s.maxOutputSize,c=s.iouThreshold,d=s.scoreThreshold,p=r,h=p.readSync(a.dataId),f=p.readSync(u.dataId),v=l,x=c,g=d;return t.kernel_impls.nonMaxSuppressionV3Impl(h,f,v,x,g)}},so=t.kernel_impls.nonMaxSuppressionV4Impl,lo={kernelName:t.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,r=e.backend,o=e.attrs;t.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var i=n,a=i.boxes,u=i.scores,s=o,l=s.maxOutputSize,c=s.iouThreshold,d=s.scoreThreshold,p=s.padToMaxOutputSize,h=r,f=h.readSync(a.dataId),v=h.readSync(u.dataId),x=so(f,v,l,c,d,p);return[x.selectedIndices,x.validOutputs]}},co=t.kernel_impls.nonMaxSuppressionV5Impl,po={kernelName:t.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,r=e.backend,o=e.attrs;t.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var i=n,a=i.boxes,u=i.scores,s=o,l=s.maxOutputSize,c=s.iouThreshold,d=s.scoreThreshold,p=s.softNmsSigma,h=r,f=h.readSync(a.dataId),v=h.readSync(u.dataId),x=co(f,v,l,c,d,p);return[x.selectedIndices,x.selectedScores]}},ho=function(e,n,r,o){this.variableNames=["Image"],this.outputShape=[];var i=e[1],a=e[2],u=Math.sin(n).toFixed(3),s=Math.cos(n).toFixed(3);this.outputShape=e;var l=t.backend_util.getImageCenter(o,i,a),c=l[0],d=l[1],p=c.toFixed(3),h=d.toFixed(3),f="";f="number"==typeof r?"float outputValue = "+r.toFixed(2)+";":"\n        vec3 fill = vec3("+r.join(",")+");\n        float outputValue = fill[coords[3]];",this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - "+p+") * "+s+" - (float(y) - "+h+") * "+u+";\n          float coordYFloat = (float(x) - "+p+") * "+u+" + (float(y) - "+h+") * "+s+";\n          int coordX = int(round(coordXFloat + "+p+"));\n          int coordY = int(round(coordYFloat + "+h+"));\n          "+f+"\n          if(coordX >= 0 && coordX < "+a+" && coordY >= 0 && coordY < "+i+") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    "},fo={kernelName:t.RotateWithOffset,backendName:"webgl",kernelFunc:function(e){var t=e.inputs,n=e.attrs,r=e.backend,o=t.image,i=n,a=i.radians,u=i.fillValue,s=i.center,l=r,c=new ho(o.shape,a,u,s);return l.runWebGLProgram(c,[o],o.dtype)}},vo=Sr("if (isnan(x)) return x;\n  return sin(x);\n"),xo={kernelName:t.Sin,backendName:"webgl",kernelFunc:vo},go=Sr("return x * x;"),mo={kernelName:t.Square,backendName:"webgl",kernelFunc:go},Co=Nr("return (a - b) * (a - b);","return (a - b) * (a - b);"),Ro={kernelName:t.SquaredDifference,backendName:"webgl",kernelFunc:Co},yo=Sr("return tan(x);");for(var bo=0,wo=[Dr,Pr,Vr,Ur,zr,Hr,Kr,Qr,Br,ro,oo,io,ao,uo,lo,po,$r,fo,xo,mo,Ro,{kernelName:t.Tan,backendName:"webgl",kernelFunc:yo},{kernelName:t.Transpose,backendName:"webgl",kernelFunc:function(e){for(var t,n=e.inputs,r=e.attrs,o=e.backend,i=n.x,a=r.perm,u=o,s=i.shape.length,l=new Array(s),c=0;c<l.length;c++)l[c]=i.shape[a[c]];if(u.shouldExecuteOnCPU([i])){var d=u.texData.get(i.dataId).values,p=Ne(d,i.shape,i.dtype,a,l);t=u.makeTensorInfo(l,i.dtype),u.texData.get(t.dataId).values=p}else t=no(i,a,u);return t}},{kernelName:t.Unique,backendName:"webgl",kernelFunc:function(e){var t=e.inputs,n=e.attrs,r=e.backend,o=n.axis,i=t.x;ie(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");var a=r.readSync(i.dataId),u=Fe(a,o,i.shape,i.dtype),s=u.outputValues,l=u.outputShape,c=u.indices;return[r.makeTensorInfo(l,i.dtype,s),r.makeTensorInfo([c.length],"int32",c)]}}];bo<wo.length;bo++){var Eo=wo[bo];t.registerKernel(Eo)}e.GPGPUContext=mn,e.MathBackendWebGL=Tr,e.forceHalfFloat=_r,e.gpgpu_util=gn,e.setWebGLContext=c,e.version_webgl="2.6.0",e.webgl=Or,e.webgl_util=ae,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-backend-webgl.min.js.map
